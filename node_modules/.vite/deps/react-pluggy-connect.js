import {
  require_react
} from "./chunk-ZMLY2J2T.js";
import {
  __commonJS,
  __toESM
} from "./chunk-4B2QHNJT.js";

// node_modules/zoid/dist/zoid.frameworks.frame.js
var require_zoid_frameworks_frame = __commonJS({
  "node_modules/zoid/dist/zoid.frameworks.frame.js"(exports, module) {
    !function(root, factory) {
      "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define("zoid", [], factory) : "object" == typeof exports ? exports.zoid = factory() : root.zoid = factory();
    }("undefined" != typeof self ? self : exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) return installedModules[moduleId].exports;
          var module2 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          __webpack_require__.o(exports2, name) || Object.defineProperty(exports2, name, {
            enumerable: true,
            get: getter
          });
        };
        __webpack_require__.r = function(exports2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports2, Symbol.toStringTag, {
            value: "Module"
          });
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        };
        __webpack_require__.t = function(value, mode) {
          1 & mode && (value = __webpack_require__(value));
          if (8 & mode) return value;
          if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", {
            enumerable: true,
            value
          });
          if (2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, (function(key2) {
            return value[key2];
          }).bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function() {
            return module2.default;
          } : function() {
            return module2;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return {}.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 0);
      }([function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "PopupOpenError", function() {
          return dom_PopupOpenError;
        });
        __webpack_require__.d(__webpack_exports__, "create", function() {
          return create2;
        });
        __webpack_require__.d(__webpack_exports__, "destroy", function() {
          return component_destroy;
        });
        __webpack_require__.d(__webpack_exports__, "destroyComponents", function() {
          return destroyComponents;
        });
        __webpack_require__.d(__webpack_exports__, "destroyAll", function() {
          return destroyAll;
        });
        __webpack_require__.d(__webpack_exports__, "PROP_TYPE", function() {
          return PROP_TYPE;
        });
        __webpack_require__.d(__webpack_exports__, "PROP_SERIALIZATION", function() {
          return PROP_SERIALIZATION;
        });
        __webpack_require__.d(__webpack_exports__, "CONTEXT", function() {
          return CONTEXT;
        });
        __webpack_require__.d(__webpack_exports__, "EVENT", function() {
          return EVENT2;
        });
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        function _extends() {
          return (_extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) ({}).hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
          }).apply(this, arguments);
        }
        function utils_isPromise(item) {
          try {
            if (!item) return false;
            if ("undefined" != typeof Promise && item instanceof Promise) return true;
            if ("undefined" != typeof window && "function" == typeof window.Window && item instanceof window.Window) return false;
            if ("undefined" != typeof window && "function" == typeof window.constructor && item instanceof window.constructor) return false;
            var _toString = {}.toString;
            if (_toString) {
              var name = _toString.call(item);
              if ("[object Window]" === name || "[object global]" === name || "[object DOMWindow]" === name) return false;
            }
            if ("function" == typeof item.then) return true;
          } catch (err) {
            return false;
          }
          return false;
        }
        var dispatchedErrors = [];
        var possiblyUnhandledPromiseHandlers = [];
        var activeCount = 0;
        var flushPromise;
        function flushActive() {
          if (!activeCount && flushPromise) {
            var promise = flushPromise;
            flushPromise = null;
            promise.resolve();
          }
        }
        function startActive() {
          activeCount += 1;
        }
        function endActive() {
          activeCount -= 1;
          flushActive();
        }
        var promise_ZalgoPromise = function() {
          function ZalgoPromise(handler) {
            var _this = this;
            this.resolved = void 0;
            this.rejected = void 0;
            this.errorHandled = void 0;
            this.value = void 0;
            this.error = void 0;
            this.handlers = void 0;
            this.dispatching = void 0;
            this.stack = void 0;
            this.resolved = false;
            this.rejected = false;
            this.errorHandled = false;
            this.handlers = [];
            if (handler) {
              var _result;
              var _error;
              var resolved = false;
              var rejected = false;
              var isAsync = false;
              startActive();
              try {
                handler(function(res) {
                  if (isAsync) _this.resolve(res);
                  else {
                    resolved = true;
                    _result = res;
                  }
                }, function(err) {
                  if (isAsync) _this.reject(err);
                  else {
                    rejected = true;
                    _error = err;
                  }
                });
              } catch (err) {
                endActive();
                this.reject(err);
                return;
              }
              endActive();
              isAsync = true;
              resolved ? this.resolve(_result) : rejected && this.reject(_error);
            }
          }
          var _proto = ZalgoPromise.prototype;
          _proto.resolve = function(result) {
            if (this.resolved || this.rejected) return this;
            if (utils_isPromise(result)) throw new Error("Can not resolve promise with another promise");
            this.resolved = true;
            this.value = result;
            this.dispatch();
            return this;
          };
          _proto.reject = function(error) {
            var _this2 = this;
            if (this.resolved || this.rejected) return this;
            if (utils_isPromise(error)) throw new Error("Can not reject promise with another promise");
            if (!error) {
              var _err = error && "function" == typeof error.toString ? error.toString() : {}.toString.call(error);
              error = new Error("Expected reject to be called with Error, got " + _err);
            }
            this.rejected = true;
            this.error = error;
            this.errorHandled || setTimeout(function() {
              _this2.errorHandled || function(err, promise) {
                if (-1 === dispatchedErrors.indexOf(err)) {
                  dispatchedErrors.push(err);
                  setTimeout(function() {
                    throw err;
                  }, 1);
                  for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);
                }
              }(error, _this2);
            }, 1);
            this.dispatch();
            return this;
          };
          _proto.asyncReject = function(error) {
            this.errorHandled = true;
            this.reject(error);
            return this;
          };
          _proto.dispatch = function() {
            var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;
            if (!this.dispatching && (resolved || rejected)) {
              this.dispatching = true;
              startActive();
              var chain = function(firstPromise, secondPromise) {
                return firstPromise.then(function(res) {
                  secondPromise.resolve(res);
                }, function(err) {
                  secondPromise.reject(err);
                });
              };
              for (var i = 0; i < handlers.length; i++) {
                var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;
                var _result2 = void 0;
                if (resolved) try {
                  _result2 = onSuccess ? onSuccess(this.value) : this.value;
                } catch (err) {
                  promise.reject(err);
                  continue;
                }
                else if (rejected) {
                  if (!onError) {
                    promise.reject(this.error);
                    continue;
                  }
                  try {
                    _result2 = onError(this.error);
                  } catch (err) {
                    promise.reject(err);
                    continue;
                  }
                }
                if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {
                  _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error);
                  _result2.errorHandled = true;
                } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);
              }
              handlers.length = 0;
              this.dispatching = false;
              endActive();
            }
          };
          _proto.then = function(onSuccess, onError) {
            if (onSuccess && "function" != typeof onSuccess && !onSuccess.call) throw new Error("Promise.then expected a function for success handler");
            if (onError && "function" != typeof onError && !onError.call) throw new Error("Promise.then expected a function for error handler");
            var promise = new ZalgoPromise();
            this.handlers.push({
              promise,
              onSuccess,
              onError
            });
            this.errorHandled = true;
            this.dispatch();
            return promise;
          };
          _proto.catch = function(onError) {
            return this.then(void 0, onError);
          };
          _proto.finally = function(onFinally) {
            if (onFinally && "function" != typeof onFinally && !onFinally.call) throw new Error("Promise.finally expected a function");
            return this.then(function(result) {
              return ZalgoPromise.try(onFinally).then(function() {
                return result;
              });
            }, function(err) {
              return ZalgoPromise.try(onFinally).then(function() {
                throw err;
              });
            });
          };
          _proto.timeout = function(time, err) {
            var _this3 = this;
            if (this.resolved || this.rejected) return this;
            var timeout = setTimeout(function() {
              _this3.resolved || _this3.rejected || _this3.reject(err || new Error("Promise timed out after " + time + "ms"));
            }, time);
            return this.then(function(result) {
              clearTimeout(timeout);
              return result;
            });
          };
          _proto.toPromise = function() {
            if ("undefined" == typeof Promise) throw new TypeError("Could not find Promise");
            return Promise.resolve(this);
          };
          ZalgoPromise.resolve = function(value) {
            return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise(function(resolve, reject) {
              return value.then(resolve, reject);
            }) : new ZalgoPromise().resolve(value);
          };
          ZalgoPromise.reject = function(error) {
            return new ZalgoPromise().reject(error);
          };
          ZalgoPromise.asyncReject = function(error) {
            return new ZalgoPromise().asyncReject(error);
          };
          ZalgoPromise.all = function(promises) {
            var promise = new ZalgoPromise();
            var count = promises.length;
            var results = [];
            if (!count) {
              promise.resolve(results);
              return promise;
            }
            var chain = function(i2, firstPromise, secondPromise) {
              return firstPromise.then(function(res) {
                results[i2] = res;
                0 == (count -= 1) && promise.resolve(results);
              }, function(err) {
                secondPromise.reject(err);
              });
            };
            for (var i = 0; i < promises.length; i++) {
              var prom = promises[i];
              if (prom instanceof ZalgoPromise) {
                if (prom.resolved) {
                  results[i] = prom.value;
                  count -= 1;
                  continue;
                }
              } else if (!utils_isPromise(prom)) {
                results[i] = prom;
                count -= 1;
                continue;
              }
              chain(i, ZalgoPromise.resolve(prom), promise);
            }
            0 === count && promise.resolve(results);
            return promise;
          };
          ZalgoPromise.hash = function(promises) {
            var result = {};
            var awaitPromises = [];
            var _loop = function(key2) {
              if (promises.hasOwnProperty(key2)) {
                var value = promises[key2];
                utils_isPromise(value) ? awaitPromises.push(value.then(function(res) {
                  result[key2] = res;
                })) : result[key2] = value;
              }
            };
            for (var key in promises) _loop(key);
            return ZalgoPromise.all(awaitPromises).then(function() {
              return result;
            });
          };
          ZalgoPromise.map = function(items, method) {
            return ZalgoPromise.all(items.map(method));
          };
          ZalgoPromise.onPossiblyUnhandledException = function(handler) {
            return function(handler2) {
              possiblyUnhandledPromiseHandlers.push(handler2);
              return {
                cancel: function() {
                  possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler2), 1);
                }
              };
            }(handler);
          };
          ZalgoPromise.try = function(method, context, args) {
            if (method && "function" != typeof method && !method.call) throw new Error("Promise.try expected a function");
            var result;
            startActive();
            try {
              result = method.apply(context, args || []);
            } catch (err) {
              endActive();
              return ZalgoPromise.reject(err);
            }
            endActive();
            return ZalgoPromise.resolve(result);
          };
          ZalgoPromise.delay = function(_delay) {
            return new ZalgoPromise(function(resolve) {
              setTimeout(resolve, _delay);
            });
          };
          ZalgoPromise.isPromise = function(value) {
            return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);
          };
          ZalgoPromise.flush = function() {
            return function(Zalgo) {
              var promise = flushPromise = flushPromise || new Zalgo();
              flushActive();
              return promise;
            }(ZalgoPromise);
          };
          return ZalgoPromise;
        }();
        function isRegex(item) {
          return "[object RegExp]" === {}.toString.call(item);
        }
        var WINDOW_TYPE = {
          IFRAME: "iframe",
          POPUP: "popup"
        };
        var IE_WIN_ACCESS_ERROR = "Call was rejected by callee.\r\n";
        function isAboutProtocol(win) {
          void 0 === win && (win = window);
          return "about:" === win.location.protocol;
        }
        function utils_getParent(win) {
          void 0 === win && (win = window);
          if (win) try {
            if (win.parent && win.parent !== win) return win.parent;
          } catch (err) {
          }
        }
        function getOpener(win) {
          void 0 === win && (win = window);
          if (win && !utils_getParent(win)) try {
            return win.opener;
          } catch (err) {
          }
        }
        function canReadFromWindow(win) {
          try {
            return true;
          } catch (err) {
          }
          return false;
        }
        function getActualDomain(win) {
          void 0 === win && (win = window);
          var location = win.location;
          if (!location) throw new Error("Can not read window location");
          var protocol = location.protocol;
          if (!protocol) throw new Error("Can not read window protocol");
          if ("file:" === protocol) return "file://";
          if ("about:" === protocol) {
            var parent = utils_getParent(win);
            return parent && canReadFromWindow() ? getActualDomain(parent) : "about://";
          }
          var host = location.host;
          if (!host) throw new Error("Can not read window host");
          return protocol + "//" + host;
        }
        function getDomain(win) {
          void 0 === win && (win = window);
          var domain = getActualDomain(win);
          return domain && win.mockDomain && 0 === win.mockDomain.indexOf("mock:") ? win.mockDomain : domain;
        }
        function isSameDomain(win) {
          if (!function(win2) {
            try {
              if (win2 === window) return true;
            } catch (err) {
            }
            try {
              var desc = Object.getOwnPropertyDescriptor(win2, "location");
              if (desc && false === desc.enumerable) return false;
            } catch (err) {
            }
            try {
              if (isAboutProtocol(win2) && canReadFromWindow()) return true;
            } catch (err) {
            }
            try {
              if (getActualDomain(win2) === getActualDomain(window)) return true;
            } catch (err) {
            }
            return false;
          }(win)) return false;
          try {
            if (win === window) return true;
            if (isAboutProtocol(win) && canReadFromWindow()) return true;
            if (getDomain(window) === getDomain(win)) return true;
          } catch (err) {
          }
          return false;
        }
        function assertSameDomain(win) {
          if (!isSameDomain(win)) throw new Error("Expected window to be same domain");
          return win;
        }
        function isAncestorParent(parent, child) {
          if (!parent || !child) return false;
          var childParent = utils_getParent(child);
          return childParent ? childParent === parent : -1 !== function(win) {
            var result = [];
            try {
              for (; win.parent !== win; ) {
                result.push(win.parent);
                win = win.parent;
              }
            } catch (err) {
            }
            return result;
          }(child).indexOf(parent);
        }
        function getFrames(win) {
          var result = [];
          var frames;
          try {
            frames = win.frames;
          } catch (err) {
            frames = win;
          }
          var len;
          try {
            len = frames.length;
          } catch (err) {
          }
          if (0 === len) return result;
          if (len) {
            for (var i = 0; i < len; i++) {
              var frame = void 0;
              try {
                frame = frames[i];
              } catch (err) {
                continue;
              }
              result.push(frame);
            }
            return result;
          }
          for (var _i = 0; _i < 100; _i++) {
            var _frame = void 0;
            try {
              _frame = frames[_i];
            } catch (err) {
              return result;
            }
            if (!_frame) return result;
            result.push(_frame);
          }
          return result;
        }
        function getAllChildFrames(win) {
          var result = [];
          for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {
            var frame = _getFrames2[_i3];
            result.push(frame);
            for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);
          }
          return result;
        }
        function getTop(win) {
          void 0 === win && (win = window);
          try {
            if (win.top) return win.top;
          } catch (err) {
          }
          if (utils_getParent(win) === win) return win;
          try {
            if (isAncestorParent(window, win) && window.top) return window.top;
          } catch (err) {
          }
          try {
            if (isAncestorParent(win, window) && window.top) return window.top;
          } catch (err) {
          }
          for (var _i7 = 0, _getAllChildFrames4 = getAllChildFrames(win); _i7 < _getAllChildFrames4.length; _i7++) {
            var frame = _getAllChildFrames4[_i7];
            try {
              if (frame.top) return frame.top;
            } catch (err) {
            }
            if (utils_getParent(frame) === frame) return frame;
          }
        }
        function getAllFramesInWindow(win) {
          var top = getTop(win);
          if (!top) throw new Error("Can not determine top window");
          var result = [].concat(getAllChildFrames(top), [top]);
          -1 === result.indexOf(win) && (result = [].concat(result, [win], getAllChildFrames(win)));
          return result;
        }
        var iframeWindows = [];
        var iframeFrames = [];
        function isWindowClosed(win, allowMock) {
          void 0 === allowMock && (allowMock = true);
          try {
            if (win === window) return false;
          } catch (err) {
            return true;
          }
          try {
            if (!win) return true;
          } catch (err) {
            return true;
          }
          try {
            if (win.closed) return true;
          } catch (err) {
            return !err || err.message !== IE_WIN_ACCESS_ERROR;
          }
          if (allowMock && isSameDomain(win)) try {
            if (win.mockclosed) return true;
          } catch (err) {
          }
          try {
            if (!win.parent || !win.top) return true;
          } catch (err) {
          }
          var iframeIndex = function(collection, item) {
            for (var i = 0; i < collection.length; i++) try {
              if (collection[i] === item) return i;
            } catch (err) {
            }
            return -1;
          }(iframeWindows, win);
          if (-1 !== iframeIndex) {
            var frame = iframeFrames[iframeIndex];
            if (frame && function(frame2) {
              if (!frame2.contentWindow) return true;
              if (!frame2.parentNode) return true;
              var doc = frame2.ownerDocument;
              if (doc && doc.documentElement && !doc.documentElement.contains(frame2)) {
                var parent = frame2;
                for (; parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;
                if (!parent.host || !doc.documentElement.contains(parent.host)) return true;
              }
              return false;
            }(frame)) return true;
          }
          return false;
        }
        function getAncestor(win) {
          void 0 === win && (win = window);
          return getOpener(win = win || window) || utils_getParent(win) || void 0;
        }
        function anyMatch(collection1, collection2) {
          for (var _i17 = 0; _i17 < collection1.length; _i17++) {
            var item1 = collection1[_i17];
            for (var _i19 = 0; _i19 < collection2.length; _i19++) if (item1 === collection2[_i19]) return true;
          }
          return false;
        }
        function getDistanceFromTop(win) {
          void 0 === win && (win = window);
          var distance = 0;
          var parent = win;
          for (; parent; ) (parent = utils_getParent(parent)) && (distance += 1);
          return distance;
        }
        function isSameTopWindow(win1, win2) {
          var top1 = getTop(win1) || win1;
          var top2 = getTop(win2) || win2;
          try {
            if (top1 && top2) return top1 === top2;
          } catch (err) {
          }
          var allFrames1 = getAllFramesInWindow(win1);
          var allFrames2 = getAllFramesInWindow(win2);
          if (anyMatch(allFrames1, allFrames2)) return true;
          var opener1 = getOpener(top1);
          var opener2 = getOpener(top2);
          return opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2) || opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1), false;
        }
        function matchDomain(pattern, origin) {
          if ("string" == typeof pattern) {
            if ("string" == typeof origin) return "*" === pattern || origin === pattern;
            if (isRegex(origin)) return false;
            if (Array.isArray(origin)) return false;
          }
          return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some(function(subpattern) {
            return matchDomain(subpattern, origin);
          }));
        }
        function getDomainFromUrl(url) {
          return url.match(/^(https?|mock|file):\/\//) ? url.split("/").slice(0, 3).join("/") : getDomain();
        }
        function onCloseWindow(win, callback, delay, maxtime) {
          void 0 === delay && (delay = 1e3);
          void 0 === maxtime && (maxtime = 1 / 0);
          var timeout;
          !function check() {
            if (isWindowClosed(win)) {
              timeout && clearTimeout(timeout);
              return callback();
            }
            if (maxtime <= 0) clearTimeout(timeout);
            else {
              maxtime -= delay;
              timeout = setTimeout(check, delay);
            }
          }();
          return {
            cancel: function() {
              timeout && clearTimeout(timeout);
            }
          };
        }
        function isWindow(obj) {
          try {
            if (obj === window) return true;
          } catch (err) {
            if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
          }
          try {
            if ("[object Window]" === {}.toString.call(obj)) return true;
          } catch (err) {
            if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
          }
          try {
            if (window.Window && obj instanceof window.Window) return true;
          } catch (err) {
            if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
          }
          try {
            if (obj && obj.self === obj) return true;
          } catch (err) {
            if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
          }
          try {
            if (obj && obj.parent === obj) return true;
          } catch (err) {
            if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
          }
          try {
            if (obj && obj.top === obj) return true;
          } catch (err) {
            if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
          }
          try {
            if (obj && "__unlikely_value__" === obj.__cross_domain_utils_window_check__) return false;
          } catch (err) {
            return true;
          }
          try {
            if ("postMessage" in obj && "self" in obj && "location" in obj) return true;
          } catch (err) {
          }
          return false;
        }
        function closeWindow(win) {
          try {
            win.close();
          } catch (err) {
          }
        }
        function util_safeIndexOf(collection, item) {
          for (var i = 0; i < collection.length; i++) try {
            if (collection[i] === item) return i;
          } catch (err) {
          }
          return -1;
        }
        var weakmap_CrossDomainSafeWeakMap = function() {
          function CrossDomainSafeWeakMap() {
            this.name = void 0;
            this.weakmap = void 0;
            this.keys = void 0;
            this.values = void 0;
            this.name = "__weakmap_" + (1e9 * Math.random() >>> 0) + "__";
            if (function() {
              if ("undefined" == typeof WeakMap) return false;
              if (void 0 === Object.freeze) return false;
              try {
                var testWeakMap = /* @__PURE__ */ new WeakMap();
                var testKey = {};
                Object.freeze(testKey);
                testWeakMap.set(testKey, "__testvalue__");
                return "__testvalue__" === testWeakMap.get(testKey);
              } catch (err) {
                return false;
              }
            }()) try {
              this.weakmap = /* @__PURE__ */ new WeakMap();
            } catch (err) {
            }
            this.keys = [];
            this.values = [];
          }
          var _proto = CrossDomainSafeWeakMap.prototype;
          _proto._cleanupClosedWindows = function() {
            var weakmap = this.weakmap;
            var keys = this.keys;
            for (var i = 0; i < keys.length; i++) {
              var value = keys[i];
              if (isWindow(value) && isWindowClosed(value)) {
                if (weakmap) try {
                  weakmap.delete(value);
                } catch (err) {
                }
                keys.splice(i, 1);
                this.values.splice(i, 1);
                i -= 1;
              }
            }
          };
          _proto.isSafeToReadWrite = function(key) {
            return !isWindow(key);
          };
          _proto.set = function(key, value) {
            if (!key) throw new Error("WeakMap expected key");
            var weakmap = this.weakmap;
            if (weakmap) try {
              weakmap.set(key, value);
            } catch (err) {
              delete this.weakmap;
            }
            if (this.isSafeToReadWrite(key)) try {
              var name = this.name;
              var entry = key[name];
              entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {
                value: [key, value],
                writable: true
              });
              return;
            } catch (err) {
            }
            this._cleanupClosedWindows();
            var keys = this.keys;
            var values = this.values;
            var index = util_safeIndexOf(keys, key);
            if (-1 === index) {
              keys.push(key);
              values.push(value);
            } else values[index] = value;
          };
          _proto.get = function(key) {
            if (!key) throw new Error("WeakMap expected key");
            var weakmap = this.weakmap;
            if (weakmap) try {
              if (weakmap.has(key)) return weakmap.get(key);
            } catch (err) {
              delete this.weakmap;
            }
            if (this.isSafeToReadWrite(key)) try {
              var entry = key[this.name];
              return entry && entry[0] === key ? entry[1] : void 0;
            } catch (err) {
            }
            this._cleanupClosedWindows();
            var index = util_safeIndexOf(this.keys, key);
            if (-1 !== index) return this.values[index];
          };
          _proto.delete = function(key) {
            if (!key) throw new Error("WeakMap expected key");
            var weakmap = this.weakmap;
            if (weakmap) try {
              weakmap.delete(key);
            } catch (err) {
              delete this.weakmap;
            }
            if (this.isSafeToReadWrite(key)) try {
              var entry = key[this.name];
              entry && entry[0] === key && (entry[0] = entry[1] = void 0);
            } catch (err) {
            }
            this._cleanupClosedWindows();
            var keys = this.keys;
            var index = util_safeIndexOf(keys, key);
            if (-1 !== index) {
              keys.splice(index, 1);
              this.values.splice(index, 1);
            }
          };
          _proto.has = function(key) {
            if (!key) throw new Error("WeakMap expected key");
            var weakmap = this.weakmap;
            if (weakmap) try {
              if (weakmap.has(key)) return true;
            } catch (err) {
              delete this.weakmap;
            }
            if (this.isSafeToReadWrite(key)) try {
              var entry = key[this.name];
              return !(!entry || entry[0] !== key);
            } catch (err) {
            }
            this._cleanupClosedWindows();
            return -1 !== util_safeIndexOf(this.keys, key);
          };
          _proto.getOrSet = function(key, getter) {
            if (this.has(key)) return this.get(key);
            var value = getter();
            this.set(key, value);
            return value;
          };
          return CrossDomainSafeWeakMap;
        }();
        function _getPrototypeOf(o) {
          return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          })(o);
        }
        function _setPrototypeOf(o, p) {
          return (_setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          })(o, p);
        }
        function _isNativeReflectConstruct() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if ("function" == typeof Proxy) return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            }));
            return true;
          } catch (e) {
            return false;
          }
        }
        function construct_construct(Parent, args, Class) {
          return (construct_construct = _isNativeReflectConstruct() ? Reflect.construct : function(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var instance = new (Function.bind.apply(Parent2, a))();
            Class2 && _setPrototypeOf(instance, Class2.prototype);
            return instance;
          }).apply(null, arguments);
        }
        function wrapNativeSuper_wrapNativeSuper(Class) {
          var _cache = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return (wrapNativeSuper_wrapNativeSuper = function(Class2) {
            if (null === Class2 || !(fn = Class2, -1 !== Function.toString.call(fn).indexOf("[native code]"))) return Class2;
            var fn;
            if ("function" != typeof Class2) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== _cache) {
              if (_cache.has(Class2)) return _cache.get(Class2);
              _cache.set(Class2, Wrapper);
            }
            function Wrapper() {
              return construct_construct(Class2, arguments, _getPrototypeOf(this).constructor);
            }
            Wrapper.prototype = Object.create(Class2.prototype, {
              constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            return _setPrototypeOf(Wrapper, Class2);
          })(Class);
        }
        function getFunctionName(fn) {
          return fn.name || fn.__name__ || fn.displayName || "anonymous";
        }
        function setFunctionName(fn, name) {
          try {
            delete fn.name;
            fn.name = name;
          } catch (err) {
          }
          fn.__name__ = fn.displayName = name;
          return fn;
        }
        function base64encode(str) {
          if ("function" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(m, p1) {
            return String.fromCharCode(parseInt(p1, 16));
          }));
          if ("undefined" != typeof Buffer) return Buffer.from(str, "utf8").toString("base64");
          throw new Error("Can not find window.btoa or Buffer");
        }
        function uniqueID() {
          var chars = "0123456789abcdef";
          return "xxxxxxxxxx".replace(/./g, function() {
            return chars.charAt(Math.floor(Math.random() * chars.length));
          }) + "_" + base64encode((/* @__PURE__ */ new Date()).toISOString().slice(11, 19).replace("T", ".")).replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
        }
        var objectIDs;
        function serializeArgs(args) {
          try {
            return JSON.stringify([].slice.call(args), function(subkey, val) {
              return "function" == typeof val ? "memoize[" + function(obj) {
                objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap();
                if (null == obj || "object" != typeof obj && "function" != typeof obj) throw new Error("Invalid object");
                var uid = objectIDs.get(obj);
                if (!uid) {
                  uid = typeof obj + ":" + uniqueID();
                  objectIDs.set(obj, uid);
                }
                return uid;
              }(val) + "]" : val;
            });
          } catch (err) {
            throw new Error("Arguments not serializable -- can not be used to memoize");
          }
        }
        function getEmptyObject() {
          return {};
        }
        var memoizeGlobalIndex = 0;
        var memoizeGlobalIndexValidFrom = 0;
        function memoize(method, options) {
          void 0 === options && (options = {});
          var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;
          var simpleCache;
          var thisCache;
          var memoizeIndex = memoizeGlobalIndex;
          memoizeGlobalIndex += 1;
          var memoizedFunction = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            if (memoizeIndex < memoizeGlobalIndexValidFrom) {
              simpleCache = null;
              thisCache = null;
              memoizeIndex = memoizeGlobalIndex;
              memoizeGlobalIndex += 1;
            }
            var cache;
            cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap()).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};
            var cacheKey = serializeArgs(args);
            var cacheResult = cache[cacheKey];
            if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {
              delete cache[cacheKey];
              cacheResult = null;
            }
            if (cacheResult) return cacheResult.value;
            var time = Date.now();
            var value = method.apply(this, arguments);
            cache[cacheKey] = {
              time,
              value
            };
            return value;
          };
          memoizedFunction.reset = function() {
            simpleCache = null;
            thisCache = null;
          };
          return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + "::memoized");
        }
        memoize.clear = function() {
          memoizeGlobalIndexValidFrom = memoizeGlobalIndex;
        };
        function memoizePromise(method) {
          var cache = {};
          function memoizedPromiseFunction() {
            var _arguments = arguments, _this = this;
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
            var key = serializeArgs(args);
            if (cache.hasOwnProperty(key)) return cache[key];
            cache[key] = promise_ZalgoPromise.try(function() {
              return method.apply(_this, _arguments);
            }).finally(function() {
              delete cache[key];
            });
            return cache[key];
          }
          memoizedPromiseFunction.reset = function() {
            cache = {};
          };
          return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + "::promiseMemoized");
        }
        function inlineMemoize(method, logic, args) {
          void 0 === args && (args = []);
          var cache = method.__inline_memoize_cache__ = method.__inline_memoize_cache__ || {};
          var key = serializeArgs(args);
          return cache.hasOwnProperty(key) ? cache[key] : cache[key] = logic.apply(void 0, args);
        }
        function src_util_noop() {
        }
        function once2(method) {
          var called = false;
          return setFunctionName(function() {
            if (!called) {
              called = true;
              return method.apply(this, arguments);
            }
          }, getFunctionName(method) + "::once");
        }
        function stringifyError(err, level) {
          void 0 === level && (level = 1);
          if (level >= 3) return "stringifyError stack overflow";
          try {
            if (!err) return "<unknown error: " + {}.toString.call(err) + ">";
            if ("string" == typeof err) return err;
            if (err instanceof Error) {
              var stack = err && err.stack;
              var message = err && err.message;
              if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + "\n" + stack;
              if (stack) return stack;
              if (message) return message;
            }
            return err && err.toString && "function" == typeof err.toString ? err.toString() : {}.toString.call(err);
          } catch (newErr) {
            return "Error while stringifying error: " + stringifyError(newErr, level + 1);
          }
        }
        function stringify(item) {
          return "string" == typeof item ? item : item && item.toString && "function" == typeof item.toString ? item.toString() : {}.toString.call(item);
        }
        function extend(obj, source) {
          if (!source) return obj;
          if (Object.assign) return Object.assign(obj, source);
          for (var key in source) source.hasOwnProperty(key) && (obj[key] = source[key]);
          return obj;
        }
        memoize(function(obj) {
          if (Object.values) return Object.values(obj);
          var result = [];
          for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);
          return result;
        });
        function identity(item) {
          return item;
        }
        function safeInterval(method, time) {
          var timeout;
          !function loop() {
            timeout = setTimeout(function() {
              method();
              loop();
            }, time);
          }();
          return {
            cancel: function() {
              clearTimeout(timeout);
            }
          };
        }
        function defineLazyProp(obj, key, getter) {
          if (Array.isArray(obj)) {
            if ("number" != typeof key) throw new TypeError("Array key must be number");
          } else if ("object" == typeof obj && null !== obj && "string" != typeof key) throw new TypeError("Object key must be string");
          Object.defineProperty(obj, key, {
            configurable: true,
            enumerable: true,
            get: function() {
              delete obj[key];
              var value = getter();
              obj[key] = value;
              return value;
            },
            set: function(value) {
              delete obj[key];
              obj[key] = value;
            }
          });
        }
        function arrayFrom(item) {
          return [].slice.call(item);
        }
        function isObjectObject(obj) {
          return "object" == typeof (item = obj) && null !== item && "[object Object]" === {}.toString.call(obj);
          var item;
        }
        function isPlainObject(obj) {
          if (!isObjectObject(obj)) return false;
          var constructor = obj.constructor;
          if ("function" != typeof constructor) return false;
          var prototype = constructor.prototype;
          return !!isObjectObject(prototype) && !!prototype.hasOwnProperty("isPrototypeOf");
        }
        function replaceObject(item, replacer, fullKey) {
          void 0 === fullKey && (fullKey = "");
          if (Array.isArray(item)) {
            var length = item.length;
            var result = [];
            var _loop2 = function(i2) {
              defineLazyProp(result, i2, function() {
                var itemKey = fullKey ? fullKey + "." + i2 : "" + i2;
                var child = replacer(item[i2], i2, itemKey);
                (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));
                return child;
              });
            };
            for (var i = 0; i < length; i++) _loop2(i);
            return result;
          }
          if (isPlainObject(item)) {
            var _result = {};
            var _loop3 = function(key2) {
              if (!item.hasOwnProperty(key2)) return "continue";
              defineLazyProp(_result, key2, function() {
                var itemKey = fullKey ? fullKey + "." + key2 : "" + key2;
                var child = replacer(item[key2], key2, itemKey);
                (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));
                return child;
              });
            };
            for (var key in item) _loop3(key);
            return _result;
          }
          throw new Error("Pass an object or array");
        }
        function isDefined(value) {
          return null != value;
        }
        function util_isRegex(item) {
          return "[object RegExp]" === {}.toString.call(item);
        }
        function util_getOrSet(obj, key, getter) {
          if (obj.hasOwnProperty(key)) return obj[key];
          var val = getter();
          obj[key] = val;
          return val;
        }
        function cleanup(obj) {
          var tasks = [];
          var cleaned = false;
          var cleanErr;
          return {
            set: function(name, item) {
              if (!cleaned) {
                obj[name] = item;
                this.register(function() {
                  delete obj[name];
                });
              }
              return item;
            },
            register: function(method) {
              cleaned ? method(cleanErr) : tasks.push(once2(function() {
                return method(cleanErr);
              }));
            },
            all: function(err) {
              cleanErr = err;
              var results = [];
              cleaned = true;
              for (; tasks.length; ) {
                var task = tasks.shift();
                results.push(task());
              }
              return promise_ZalgoPromise.all(results).then(src_util_noop);
            }
          };
        }
        function assertExists(name, thing) {
          if (null == thing) throw new Error("Expected " + name + " to be present");
          return thing;
        }
        var util_ExtendableError = function(_Error) {
          _inheritsLoose(ExtendableError, _Error);
          function ExtendableError(message) {
            var _this6;
            (_this6 = _Error.call(this, message) || this).name = _this6.constructor.name;
            "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(function(self2) {
              if (void 0 === self2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return self2;
            }(_this6), _this6.constructor) : _this6.stack = new Error(message).stack;
            return _this6;
          }
          return ExtendableError;
        }(wrapNativeSuper_wrapNativeSuper(Error));
        function isDocumentReady() {
          return Boolean(document.body) && "complete" === document.readyState;
        }
        function isDocumentInteractive() {
          return Boolean(document.body) && "interactive" === document.readyState;
        }
        function urlEncode(str) {
          return str.replace(/\?/g, "%3F").replace(/&/g, "%26").replace(/#/g, "%23").replace(/\+/g, "%2B");
        }
        memoize(function() {
          return new promise_ZalgoPromise(function(resolve) {
            if (isDocumentReady() || isDocumentInteractive()) return resolve();
            var interval = setInterval(function() {
              if (isDocumentReady() || isDocumentInteractive()) {
                clearInterval(interval);
                return resolve();
              }
            }, 10);
          });
        });
        function parseQuery(queryString) {
          return inlineMemoize(parseQuery, function() {
            var params = {};
            if (!queryString) return params;
            if (-1 === queryString.indexOf("=")) return params;
            for (var _i2 = 0, _queryString$split2 = queryString.split("&"); _i2 < _queryString$split2.length; _i2++) {
              var pair = _queryString$split2[_i2];
              (pair = pair.split("="))[0] && pair[1] && (params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]));
            }
            return params;
          }, [queryString]);
        }
        function extendQuery(originalQuery, props) {
          void 0 === props && (props = {});
          return props && Object.keys(props).length ? function(obj) {
            void 0 === obj && (obj = {});
            return Object.keys(obj).filter(function(key) {
              return "string" == typeof obj[key];
            }).map(function(key) {
              return urlEncode(key) + "=" + urlEncode(obj[key]);
            }).join("&");
          }(_extends({}, parseQuery(originalQuery), props)) : originalQuery;
        }
        function appendChild(container, child) {
          container.appendChild(child);
        }
        function isElement(element) {
          return element instanceof window.Element || null !== element && "object" == typeof element && 1 === element.nodeType && "object" == typeof element.style && "object" == typeof element.ownerDocument;
        }
        function getElementSafe(id, doc) {
          void 0 === doc && (doc = document);
          return isElement(id) ? id : "string" == typeof id ? doc.querySelector(id) : void 0;
        }
        function elementReady(id) {
          return new promise_ZalgoPromise(function(resolve, reject) {
            var name = stringify(id);
            var el = getElementSafe(id);
            if (el) return resolve(el);
            if (isDocumentReady()) return reject(new Error("Document is ready and element " + name + " does not exist"));
            var interval = setInterval(function() {
              if (el = getElementSafe(id)) {
                clearInterval(interval);
                return resolve(el);
              }
              if (isDocumentReady()) {
                clearInterval(interval);
                return reject(new Error("Document is ready and element " + name + " does not exist"));
              }
            }, 10);
          });
        }
        var dom_PopupOpenError = function(_ExtendableError) {
          _inheritsLoose(PopupOpenError, _ExtendableError);
          function PopupOpenError() {
            return _ExtendableError.apply(this, arguments) || this;
          }
          return PopupOpenError;
        }(util_ExtendableError);
        var awaitFrameLoadPromises;
        function awaitFrameLoad(frame) {
          if ((awaitFrameLoadPromises = awaitFrameLoadPromises || new weakmap_CrossDomainSafeWeakMap()).has(frame)) {
            var _promise = awaitFrameLoadPromises.get(frame);
            if (_promise) return _promise;
          }
          var promise = new promise_ZalgoPromise(function(resolve, reject) {
            frame.addEventListener("load", function() {
              !function(frame2) {
                !function() {
                  for (var i = 0; i < iframeWindows.length; i++) {
                    var closed = false;
                    try {
                      closed = iframeWindows[i].closed;
                    } catch (err) {
                    }
                    if (closed) {
                      iframeFrames.splice(i, 1);
                      iframeWindows.splice(i, 1);
                    }
                  }
                }();
                if (frame2 && frame2.contentWindow) try {
                  iframeWindows.push(frame2.contentWindow);
                  iframeFrames.push(frame2);
                } catch (err) {
                }
              }(frame);
              resolve(frame);
            });
            frame.addEventListener("error", function(err) {
              frame.contentWindow ? resolve(frame) : reject(err);
            });
          });
          awaitFrameLoadPromises.set(frame, promise);
          return promise;
        }
        function awaitFrameWindow(frame) {
          return awaitFrameLoad(frame).then(function(loadedFrame) {
            if (!loadedFrame.contentWindow) throw new Error("Could not find window in iframe");
            return loadedFrame.contentWindow;
          });
        }
        function dom_iframe(options, container) {
          void 0 === options && (options = {});
          var style = options.style || {};
          var frame = function(tag, options2, container2) {
            void 0 === tag && (tag = "div");
            void 0 === options2 && (options2 = {});
            tag = tag.toLowerCase();
            var element = document.createElement(tag);
            options2.style && extend(element.style, options2.style);
            options2.class && (element.className = options2.class.join(" "));
            options2.id && element.setAttribute("id", options2.id);
            if (options2.attributes) for (var _i10 = 0, _Object$keys2 = Object.keys(options2.attributes); _i10 < _Object$keys2.length; _i10++) {
              var key = _Object$keys2[_i10];
              element.setAttribute(key, options2.attributes[key]);
            }
            options2.styleSheet && function(el, styleText, doc) {
              void 0 === doc && (doc = window.document);
              el.styleSheet ? el.styleSheet.cssText = styleText : el.appendChild(doc.createTextNode(styleText));
            }(element, options2.styleSheet);
            if (options2.html) {
              if ("iframe" === tag) throw new Error("Iframe html can not be written unless container provided and iframe in DOM");
              element.innerHTML = options2.html;
            }
            return element;
          }("iframe", {
            attributes: _extends({
              allowTransparency: "true"
            }, options.attributes || {}),
            style: _extends({
              backgroundColor: "transparent",
              border: "none"
            }, style),
            html: options.html,
            class: options.class
          });
          var isIE = window.navigator.userAgent.match(/MSIE|Edge/i);
          frame.hasAttribute("id") || frame.setAttribute("id", uniqueID());
          awaitFrameLoad(frame);
          container && function(id, doc) {
            void 0 === doc && (doc = document);
            var element = getElementSafe(id, doc);
            if (element) return element;
            throw new Error("Can not find element: " + stringify(id));
          }(container).appendChild(frame);
          (options.url || isIE) && frame.setAttribute("src", options.url || "about:blank");
          return frame;
        }
        function addEventListener(obj, event, handler) {
          obj.addEventListener(event, handler);
          return {
            cancel: function() {
              obj.removeEventListener(event, handler);
            }
          };
        }
        function showElement(element) {
          element.style.setProperty("display", "");
        }
        function hideElement(element) {
          element.style.setProperty("display", "none", "important");
        }
        function destroyElement(element) {
          element && element.parentNode && element.parentNode.removeChild(element);
        }
        function isElementClosed(el) {
          return !(el && el.parentNode && el.ownerDocument && el.ownerDocument.documentElement && el.ownerDocument.documentElement.contains(el));
        }
        function onResize(el, handler, _temp) {
          var _ref2 = void 0 === _temp ? {} : _temp, _ref2$width = _ref2.width, width = void 0 === _ref2$width || _ref2$width, _ref2$height = _ref2.height, height = void 0 === _ref2$height || _ref2$height, _ref2$interval = _ref2.interval, interval = void 0 === _ref2$interval ? 100 : _ref2$interval, _ref2$win = _ref2.win, win = void 0 === _ref2$win ? window : _ref2$win;
          var currentWidth = el.offsetWidth;
          var currentHeight = el.offsetHeight;
          var canceled = false;
          handler({
            width: currentWidth,
            height: currentHeight
          });
          var check = function() {
            if (!canceled && function(el2) {
              return Boolean(el2.offsetWidth || el2.offsetHeight || el2.getClientRects().length);
            }(el)) {
              var newWidth = el.offsetWidth;
              var newHeight = el.offsetHeight;
              (width && newWidth !== currentWidth || height && newHeight !== currentHeight) && handler({
                width: newWidth,
                height: newHeight
              });
              currentWidth = newWidth;
              currentHeight = newHeight;
            }
          };
          var observer;
          var timeout;
          win.addEventListener("resize", check);
          if (void 0 !== win.ResizeObserver) {
            (observer = new win.ResizeObserver(check)).observe(el);
            timeout = safeInterval(check, 10 * interval);
          } else if (void 0 !== win.MutationObserver) {
            (observer = new win.MutationObserver(check)).observe(el, {
              attributes: true,
              childList: true,
              subtree: true,
              characterData: false
            });
            timeout = safeInterval(check, 10 * interval);
          } else timeout = safeInterval(check, interval);
          return {
            cancel: function() {
              canceled = true;
              observer.disconnect();
              window.removeEventListener("resize", check);
              timeout.cancel();
            }
          };
        }
        function isShadowElement(element) {
          for (; element.parentNode; ) element = element.parentNode;
          return "[object ShadowRoot]" === element.toString();
        }
        var currentScript = "undefined" != typeof document ? document.currentScript : null;
        var getCurrentScript = memoize(function() {
          if (currentScript) return currentScript;
          if (currentScript = function() {
            try {
              var stack = function() {
                try {
                  throw new Error("_");
                } catch (err) {
                  return err.stack || "";
                }
              }();
              var stackDetails = /.*at [^(]*\((.*):(.+):(.+)\)$/gi.exec(stack);
              var scriptLocation = stackDetails && stackDetails[1];
              if (!scriptLocation) return;
              for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName("script")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {
                var script = _Array$prototype$slic2[_i22];
                if (script.src && script.src === scriptLocation) return script;
              }
            } catch (err) {
            }
          }()) return currentScript;
          throw new Error("Can not determine current script");
        });
        var currentUID = uniqueID();
        memoize(function() {
          var script;
          try {
            script = getCurrentScript();
          } catch (err) {
            return currentUID;
          }
          var uid = script.getAttribute("data-uid");
          if (uid && "string" == typeof uid) return uid;
          if ((uid = script.getAttribute("data-uid-auto")) && "string" == typeof uid) return uid;
          uid = uniqueID();
          script.setAttribute("data-uid-auto", uid);
          return uid;
        });
        function toPx(val) {
          return function(val2) {
            if ("number" == typeof val2) return val2;
            var match = val2.match(/^([0-9]+)(px|%)$/);
            if (!match) throw new Error("Could not match css value from " + val2);
            return parseInt(match[1], 10);
          }(val) + "px";
        }
        function toCSS(val) {
          return "number" == typeof val ? toPx(val) : "string" == typeof (str = val) && /^[0-9]+%$/.test(str) ? val : toPx(val);
          var str;
        }
        function global_getGlobal(win) {
          void 0 === win && (win = window);
          var globalKey = "__post_robot_10_0_42__";
          return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};
        }
        var getObj = function() {
          return {};
        };
        function globalStore(key, defStore) {
          void 0 === key && (key = "store");
          void 0 === defStore && (defStore = getObj);
          return util_getOrSet(global_getGlobal(), key, function() {
            var store = defStore();
            return {
              has: function(storeKey) {
                return store.hasOwnProperty(storeKey);
              },
              get: function(storeKey, defVal) {
                return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;
              },
              set: function(storeKey, val) {
                store[storeKey] = val;
                return val;
              },
              del: function(storeKey) {
                delete store[storeKey];
              },
              getOrSet: function(storeKey, getter) {
                return util_getOrSet(store, storeKey, getter);
              },
              reset: function() {
                store = defStore();
              },
              keys: function() {
                return Object.keys(store);
              }
            };
          });
        }
        var WildCard = function() {
        };
        function getWildcard() {
          var global = global_getGlobal();
          global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard();
          return global.WINDOW_WILDCARD;
        }
        function windowStore(key, defStore) {
          void 0 === key && (key = "store");
          void 0 === defStore && (defStore = getObj);
          return globalStore("windowStore").getOrSet(key, function() {
            var winStore = new weakmap_CrossDomainSafeWeakMap();
            var getStore = function(win) {
              return winStore.getOrSet(win, defStore);
            };
            return {
              has: function(win) {
                return getStore(win).hasOwnProperty(key);
              },
              get: function(win, defVal) {
                var store = getStore(win);
                return store.hasOwnProperty(key) ? store[key] : defVal;
              },
              set: function(win, val) {
                getStore(win)[key] = val;
                return val;
              },
              del: function(win) {
                delete getStore(win)[key];
              },
              getOrSet: function(win, getter) {
                return util_getOrSet(getStore(win), key, getter);
              }
            };
          });
        }
        function getInstanceID() {
          return globalStore("instance").getOrSet("instanceID", uniqueID);
        }
        function resolveHelloPromise(win, _ref) {
          var domain = _ref.domain;
          var helloPromises = windowStore("helloPromises");
          var existingPromise = helloPromises.get(win);
          existingPromise && existingPromise.resolve({
            domain
          });
          var newPromise = promise_ZalgoPromise.resolve({
            domain
          });
          helloPromises.set(win, newPromise);
          return newPromise;
        }
        function sayHello(win, _ref4) {
          return (0, _ref4.send)(win, "postrobot_hello", {
            instanceID: getInstanceID()
          }, {
            domain: "*",
            timeout: -1
          }).then(function(_ref5) {
            var origin = _ref5.origin, instanceID = _ref5.data.instanceID;
            resolveHelloPromise(win, {
              domain: origin
            });
            return {
              win,
              domain: origin,
              instanceID
            };
          });
        }
        function getWindowInstanceID(win, _ref6) {
          var send = _ref6.send;
          return windowStore("windowInstanceIDPromises").getOrSet(win, function() {
            return sayHello(win, {
              send
            }).then(function(_ref7) {
              return _ref7.instanceID;
            });
          });
        }
        function markWindowKnown(win) {
          windowStore("knownWindows").set(win, true);
        }
        function isSerializedType(item) {
          return "object" == typeof item && null !== item && "string" == typeof item.__type__;
        }
        function determineType(val) {
          return void 0 === val ? "undefined" : null === val ? "null" : Array.isArray(val) ? "array" : "function" == typeof val ? "function" : "object" == typeof val ? val instanceof Error ? "error" : "function" == typeof val.then ? "promise" : "[object RegExp]" === {}.toString.call(val) ? "regex" : "[object Date]" === {}.toString.call(val) ? "date" : "object" : "string" == typeof val ? "string" : "number" == typeof val ? "number" : "boolean" == typeof val ? "boolean" : void 0;
        }
        function serializeType(type, val) {
          return {
            __type__: type,
            __val__: val
          };
        }
        var _SERIALIZER;
        var SERIALIZER = ((_SERIALIZER = {}).function = function() {
        }, _SERIALIZER.error = function(_ref) {
          return serializeType("error", {
            message: _ref.message,
            stack: _ref.stack,
            code: _ref.code,
            data: _ref.data
          });
        }, _SERIALIZER.promise = function() {
        }, _SERIALIZER.regex = function(val) {
          return serializeType("regex", val.source);
        }, _SERIALIZER.date = function(val) {
          return serializeType("date", val.toJSON());
        }, _SERIALIZER.array = function(val) {
          return val;
        }, _SERIALIZER.object = function(val) {
          return val;
        }, _SERIALIZER.string = function(val) {
          return val;
        }, _SERIALIZER.number = function(val) {
          return val;
        }, _SERIALIZER.boolean = function(val) {
          return val;
        }, _SERIALIZER.null = function(val) {
          return val;
        }, _SERIALIZER);
        var defaultSerializers = {};
        var _DESERIALIZER;
        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {
          throw new Error("Function serialization is not implemented; nothing to deserialize");
        }, _DESERIALIZER.error = function(_ref2) {
          var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;
          var error = new Error(_ref2.message);
          error.code = code;
          data && (error.data = data);
          error.stack = stack + "\n\n" + error.stack;
          return error;
        }, _DESERIALIZER.promise = function() {
          throw new Error("Promise serialization is not implemented; nothing to deserialize");
        }, _DESERIALIZER.regex = function(val) {
          return new RegExp(val);
        }, _DESERIALIZER.date = function(val) {
          return new Date(val);
        }, _DESERIALIZER.array = function(val) {
          return val;
        }, _DESERIALIZER.object = function(val) {
          return val;
        }, _DESERIALIZER.string = function(val) {
          return val;
        }, _DESERIALIZER.number = function(val) {
          return val;
        }, _DESERIALIZER.boolean = function(val) {
          return val;
        }, _DESERIALIZER.null = function(val) {
          return val;
        }, _DESERIALIZER);
        var defaultDeserializers = {};
        new promise_ZalgoPromise(function(resolve) {
          if (window.document && window.document.body) return resolve(window.document.body);
          var interval = setInterval(function() {
            if (window.document && window.document.body) {
              clearInterval(interval);
              return resolve(window.document.body);
            }
          }, 10);
        });
        function cleanupProxyWindows() {
          var idToProxyWindow = globalStore("idToProxyWindow");
          for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {
            var id = _idToProxyWindow$keys2[_i2];
            idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);
          }
        }
        function getSerializedWindow(winPromise, _ref) {
          var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;
          var windowNamePromise = winPromise.then(function(win) {
            if (isSameDomain(win)) return assertSameDomain(win).name;
          });
          var windowTypePromise = winPromise.then(function(window2) {
            if (isWindowClosed(window2)) throw new Error("Window is closed, can not determine type");
            return getOpener(window2) ? WINDOW_TYPE.POPUP : WINDOW_TYPE.IFRAME;
          });
          windowNamePromise.catch(src_util_noop);
          windowTypePromise.catch(src_util_noop);
          return {
            id,
            getType: function() {
              return windowTypePromise;
            },
            getInstanceID: memoizePromise(function() {
              return winPromise.then(function(win) {
                return getWindowInstanceID(win, {
                  send
                });
              });
            }),
            close: function() {
              return winPromise.then(closeWindow);
            },
            getName: function() {
              return winPromise.then(function(win) {
                if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;
              });
            },
            focus: function() {
              return winPromise.then(function(win) {
                win.focus();
              });
            },
            isClosed: function() {
              return winPromise.then(function(win) {
                return isWindowClosed(win);
              });
            },
            setLocation: function(href) {
              return winPromise.then(function(win) {
                var domain = window.location.protocol + "//" + window.location.host;
                if (0 === href.indexOf("/")) href = "" + domain + href;
                else if (!href.match(/^https?:\/\//) && 0 !== href.indexOf(domain)) throw new Error("Expected url to be http or https url, or absolute path, got " + JSON.stringify(href));
                if (isSameDomain(win)) try {
                  if (win.location && "function" == typeof win.location.replace) {
                    win.location.replace(href);
                    return;
                  }
                } catch (err) {
                }
                win.location = href;
              });
            },
            setName: function(name) {
              return winPromise.then(function(win) {
                var sameDomain = isSameDomain(win);
                var frame = function(win2) {
                  if (isSameDomain(win2)) return assertSameDomain(win2).frameElement;
                  for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll("iframe"); _i21 < _document$querySelect2.length; _i21++) {
                    var frame2 = _document$querySelect2[_i21];
                    if (frame2 && frame2.contentWindow && frame2.contentWindow === win2) return frame2;
                  }
                }(win);
                if (!sameDomain) throw new Error("Can not set name for cross-domain window: " + name);
                assertSameDomain(win).name = name;
                frame && frame.setAttribute("name", name);
                windowNamePromise = promise_ZalgoPromise.resolve(name);
              });
            }
          };
        }
        var window_ProxyWindow = function() {
          function ProxyWindow(_ref2) {
            var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;
            this.id = void 0;
            this.isProxyWindow = true;
            this.serializedWindow = void 0;
            this.actualWindow = void 0;
            this.actualWindowPromise = void 0;
            this.send = void 0;
            this.name = void 0;
            this.actualWindowPromise = new promise_ZalgoPromise();
            this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {
              send
            });
            globalStore("idToProxyWindow").set(this.getID(), this);
            win && this.setWindow(win, {
              send
            });
          }
          var _proto = ProxyWindow.prototype;
          _proto.getID = function() {
            return this.serializedWindow.id;
          };
          _proto.getType = function() {
            return this.serializedWindow.getType();
          };
          _proto.isPopup = function() {
            return this.getType().then(function(type) {
              return type === WINDOW_TYPE.POPUP;
            });
          };
          _proto.setLocation = function(href) {
            var _this = this;
            return this.serializedWindow.setLocation(href).then(function() {
              return _this;
            });
          };
          _proto.getName = function() {
            return this.serializedWindow.getName();
          };
          _proto.setName = function(name) {
            var _this2 = this;
            return this.serializedWindow.setName(name).then(function() {
              return _this2;
            });
          };
          _proto.close = function() {
            var _this3 = this;
            return this.serializedWindow.close().then(function() {
              return _this3;
            });
          };
          _proto.focus = function() {
            var _this4 = this;
            var isPopupPromise = this.isPopup();
            var getNamePromise = this.getName();
            var reopenPromise = promise_ZalgoPromise.hash({
              isPopup: isPopupPromise,
              name: getNamePromise
            }).then(function(_ref3) {
              var name = _ref3.name;
              _ref3.isPopup && name && window.open("", name);
            });
            var focusPromise = this.serializedWindow.focus();
            return promise_ZalgoPromise.all([reopenPromise, focusPromise]).then(function() {
              return _this4;
            });
          };
          _proto.isClosed = function() {
            return this.serializedWindow.isClosed();
          };
          _proto.getWindow = function() {
            return this.actualWindow;
          };
          _proto.setWindow = function(win, _ref4) {
            var send = _ref4.send;
            this.actualWindow = win;
            this.actualWindowPromise.resolve(this.actualWindow);
            this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {
              send,
              id: this.getID()
            });
            windowStore("winToProxyWindow").set(win, this);
          };
          _proto.awaitWindow = function() {
            return this.actualWindowPromise;
          };
          _proto.matchWindow = function(win, _ref5) {
            var _this5 = this;
            var send = _ref5.send;
            return promise_ZalgoPromise.try(function() {
              return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({
                proxyInstanceID: _this5.getInstanceID(),
                knownWindowInstanceID: getWindowInstanceID(win, {
                  send
                })
              }).then(function(_ref6) {
                var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;
                match && _this5.setWindow(win, {
                  send
                });
                return match;
              });
            });
          };
          _proto.unwrap = function() {
            return this.actualWindow || this;
          };
          _proto.getInstanceID = function() {
            return this.serializedWindow.getInstanceID();
          };
          _proto.shouldClean = function() {
            return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));
          };
          _proto.serialize = function() {
            return this.serializedWindow;
          };
          ProxyWindow.unwrap = function(win) {
            return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;
          };
          ProxyWindow.serialize = function(win, _ref7) {
            var send = _ref7.send;
            cleanupProxyWindows();
            return ProxyWindow.toProxyWindow(win, {
              send
            }).serialize();
          };
          ProxyWindow.deserialize = function(serializedWindow, _ref8) {
            var send = _ref8.send;
            cleanupProxyWindows();
            return globalStore("idToProxyWindow").get(serializedWindow.id) || new ProxyWindow({
              serializedWindow,
              send
            });
          };
          ProxyWindow.isProxyWindow = function(obj) {
            return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);
          };
          ProxyWindow.toProxyWindow = function(win, _ref9) {
            var send = _ref9.send;
            cleanupProxyWindows();
            if (ProxyWindow.isProxyWindow(win)) return win;
            var actualWindow = win;
            return windowStore("winToProxyWindow").get(actualWindow) || new ProxyWindow({
              win: actualWindow,
              send
            });
          };
          return ProxyWindow;
        }();
        function addMethod(id, val, name, source, domain) {
          var methodStore = windowStore("methodStore");
          var proxyWindowMethods = globalStore("proxyWindowMethods");
          if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {
            val,
            name,
            domain,
            source
          });
          else {
            proxyWindowMethods.del(id);
            methodStore.getOrSet(source, function() {
              return {};
            })[id] = {
              domain,
              name,
              val,
              source
            };
          }
        }
        function lookupMethod(source, id) {
          var methodStore = windowStore("methodStore");
          var proxyWindowMethods = globalStore("proxyWindowMethods");
          return methodStore.getOrSet(source, function() {
            return {};
          })[id] || proxyWindowMethods.get(id);
        }
        function function_serializeFunction(destination, domain, val, key, _ref3) {
          on = (_ref = {
            on: _ref3.on,
            send: _ref3.send
          }).on, send = _ref.send, globalStore("builtinListeners").getOrSet("functionCalls", function() {
            return on("postrobot_method", {
              domain: "*"
            }, function(_ref2) {
              var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;
              var id2 = data.id, name2 = data.name;
              var meth = lookupMethod(source, id2);
              if (!meth) throw new Error("Could not find method '" + name2 + "' with id: " + data.id + " in " + getDomain(window));
              var methodSource = meth.source, domain2 = meth.domain, val2 = meth.val;
              return promise_ZalgoPromise.try(function() {
                if (!matchDomain(domain2, origin)) throw new Error("Method '" + data.name + "' domain " + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + " does not match origin " + origin + " in " + getDomain(window));
                if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {
                  send
                }).then(function(match) {
                  if (!match) throw new Error("Method call '" + data.name + "' failed - proxy window does not match source in " + getDomain(window));
                });
              }).then(function() {
                return val2.apply({
                  source,
                  origin
                }, data.args);
              }, function(err) {
                return promise_ZalgoPromise.try(function() {
                  if (val2.onError) return val2.onError(err);
                }).then(function() {
                  err.stack && (err.stack = "Remote call to " + name2 + "(" + function(args) {
                    void 0 === args && (args = []);
                    return arrayFrom(args).map(function(arg) {
                      return "string" == typeof arg ? "'" + arg + "'" : void 0 === arg ? "undefined" : null === arg ? "null" : "boolean" == typeof arg ? arg.toString() : Array.isArray(arg) ? "[ ... ]" : "object" == typeof arg ? "{ ... }" : "function" == typeof arg ? "() => { ... }" : "<" + typeof arg + ">";
                    }).join(", ");
                  }(data.args) + ") failed\n\n" + err.stack);
                  throw err;
                });
              }).then(function(result) {
                return {
                  result,
                  id: id2,
                  name: name2
                };
              });
            });
          });
          var _ref, on, send;
          var id = val.__id__ || uniqueID();
          destination = window_ProxyWindow.unwrap(destination);
          var name = val.__name__ || val.name || key;
          "string" == typeof name && "function" == typeof name.indexOf && 0 === name.indexOf("anonymous::") && (name = name.replace("anonymous::", key + "::"));
          if (window_ProxyWindow.isProxyWindow(destination)) {
            addMethod(id, val, name, destination, domain);
            destination.awaitWindow().then(function(win) {
              addMethod(id, val, name, win, domain);
            });
          } else addMethod(id, val, name, destination, domain);
          return serializeType("cross_domain_function", {
            id,
            name
          });
        }
        function serializeMessage(destination, domain, obj, _ref) {
          var _serialize;
          var on = _ref.on, send = _ref.send;
          return function(obj2, serializers) {
            void 0 === serializers && (serializers = defaultSerializers);
            var result = JSON.stringify(obj2, function(key) {
              var val = this[key];
              if (isSerializedType(this)) return val;
              var type = determineType(val);
              if (!type) return val;
              var serializer = serializers[type] || SERIALIZER[type];
              return serializer ? serializer(val, key) : val;
            });
            return void 0 === result ? "undefined" : result;
          }(obj, ((_serialize = {}).promise = function(val, key) {
            return function(destination2, domain2, val2, key2, _ref2) {
              return serializeType("cross_domain_zalgo_promise", {
                then: function_serializeFunction(destination2, domain2, function(resolve, reject) {
                  return val2.then(resolve, reject);
                }, key2, {
                  on: _ref2.on,
                  send: _ref2.send
                })
              });
            }(destination, domain, val, key, {
              on,
              send
            });
          }, _serialize.function = function(val, key) {
            return function_serializeFunction(destination, domain, val, key, {
              on,
              send
            });
          }, _serialize.object = function(val) {
            return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType("cross_domain_window", window_ProxyWindow.serialize(val, {
              send
            })) : val;
          }, _serialize));
        }
        function deserializeMessage(source, origin, message, _ref2) {
          var _deserialize;
          var send = _ref2.send;
          return function(str, deserializers) {
            void 0 === deserializers && (deserializers = defaultDeserializers);
            if ("undefined" !== str) return JSON.parse(str, function(key, val) {
              if (isSerializedType(this)) return val;
              var type;
              var value;
              if (isSerializedType(val)) {
                type = val.__type__;
                value = val.__val__;
              } else {
                type = determineType(val);
                value = val;
              }
              if (!type) return value;
              var deserializer = deserializers[type] || DESERIALIZER[type];
              return deserializer ? deserializer(value, key) : value;
            });
          }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {
            return function(source2, origin2, _ref22) {
              return new promise_ZalgoPromise(_ref22.then);
            }(0, 0, serializedPromise);
          }, _deserialize.cross_domain_function = function(serializedFunction) {
            return function(source2, origin2, _ref4, _ref5) {
              var id = _ref4.id, name = _ref4.name;
              var send2 = _ref5.send;
              var getDeserializedFunction = function(opts) {
                void 0 === opts && (opts = {});
                function crossDomainFunctionWrapper2() {
                  var _arguments = arguments;
                  return window_ProxyWindow.toProxyWindow(source2, {
                    send: send2
                  }).awaitWindow().then(function(win) {
                    var meth = lookupMethod(win, id);
                    if (meth && meth.val !== crossDomainFunctionWrapper2) return meth.val.apply({
                      source: window,
                      origin: getDomain()
                    }, _arguments);
                    var _args = [].slice.call(_arguments);
                    return opts.fireAndForget ? send2(win, "postrobot_method", {
                      id,
                      name,
                      args: _args
                    }, {
                      domain: origin2,
                      fireAndForget: true
                    }) : send2(win, "postrobot_method", {
                      id,
                      name,
                      args: _args
                    }, {
                      domain: origin2,
                      fireAndForget: false
                    }).then(function(res) {
                      return res.data.result;
                    });
                  }).catch(function(err) {
                    throw err;
                  });
                }
                crossDomainFunctionWrapper2.__name__ = name;
                crossDomainFunctionWrapper2.__origin__ = origin2;
                crossDomainFunctionWrapper2.__source__ = source2;
                crossDomainFunctionWrapper2.__id__ = id;
                crossDomainFunctionWrapper2.origin = origin2;
                return crossDomainFunctionWrapper2;
              };
              var crossDomainFunctionWrapper = getDeserializedFunction();
              crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({
                fireAndForget: true
              });
              return crossDomainFunctionWrapper;
            }(source, origin, serializedFunction, {
              send
            });
          }, _deserialize.cross_domain_window = function(serializedWindow) {
            return window_ProxyWindow.deserialize(serializedWindow, {
              send
            });
          }, _deserialize));
        }
        var SEND_MESSAGE_STRATEGIES = {};
        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {
          0 === domain.indexOf("file:") && (domain = "*");
          win.postMessage(serializedMessage, domain);
        };
        SEND_MESSAGE_STRATEGIES.postrobot_global = function(win, serializedMessage) {
          if (!function(win2) {
            return (win2 = win2 || window).navigator.mockUserAgent || win2.navigator.userAgent;
          }(window).match(/MSIE|rv:11|trident|edge\/12|edge\/13/i)) throw new Error("Global messaging not needed for browser");
          if (!isSameDomain(win)) throw new Error("Post message through global disabled between different domain windows");
          if (false !== isSameTopWindow(window, win)) throw new Error("Can only use global to communicate between two different windows, not between frames");
          var foreignGlobal = global_getGlobal(win);
          if (!foreignGlobal) throw new Error("Can not find postRobot global on foreign window");
          foreignGlobal.receiveMessage({
            source: window,
            origin: getDomain(),
            data: serializedMessage
          });
        };
        function send_sendMessage(win, domain, message, _ref2) {
          var on = _ref2.on, send = _ref2.send;
          return promise_ZalgoPromise.try(function() {
            var domainBuffer = windowStore().getOrSet(win, function() {
              return {};
            });
            domainBuffer.buffer = domainBuffer.buffer || [];
            domainBuffer.buffer.push(message);
            domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then(function() {
              if (isWindowClosed(win)) throw new Error("Window is closed");
              var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_42__ = domainBuffer.buffer || [], _ref), {
                on,
                send
              });
              var _ref;
              delete domainBuffer.buffer;
              var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);
              var errors = [];
              for (var _i2 = 0; _i2 < strategies.length; _i2++) {
                var strategyName = strategies[_i2];
                try {
                  SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);
                } catch (err) {
                  errors.push(err);
                }
              }
              if (errors.length === strategies.length) throw new Error("All post-robot messaging strategies failed:\n\n" + errors.map(function(err, i) {
                return i + ". " + stringifyError(err);
              }).join("\n\n"));
            });
            return domainBuffer.flush.then(function() {
              delete domainBuffer.flush;
            });
          }).then(src_util_noop);
        }
        function getResponseListener(hash) {
          return globalStore("responseListeners").get(hash);
        }
        function deleteResponseListener(hash) {
          globalStore("responseListeners").del(hash);
        }
        function isResponseListenerErrored(hash) {
          return globalStore("erroredResponseListeners").has(hash);
        }
        function getRequestListener(_ref) {
          var name = _ref.name, win = _ref.win, domain = _ref.domain;
          var requestListeners = windowStore("requestListeners");
          "*" === win && (win = null);
          "*" === domain && (domain = null);
          if (!name) throw new Error("Name required to get request listener");
          for (var _i4 = 0, _ref3 = [win, getWildcard()]; _i4 < _ref3.length; _i4++) {
            var winQualifier = _ref3[_i4];
            if (winQualifier) {
              var nameListeners = requestListeners.get(winQualifier);
              if (nameListeners) {
                var domainListeners = nameListeners[name];
                if (domainListeners) {
                  if (domain && "string" == typeof domain) {
                    if (domainListeners[domain]) return domainListeners[domain];
                    if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {
                      var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;
                      if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;
                    }
                  }
                  if (domainListeners["*"]) return domainListeners["*"];
                }
              }
            }
          }
        }
        function handleRequest(source, origin, message, _ref) {
          var on = _ref.on, send = _ref.send;
          var options = getRequestListener({
            name: message.name,
            win: source,
            domain: origin
          });
          var logName = "postrobot_method" === message.name && message.data && "string" == typeof message.data.name ? message.data.name + "()" : message.name;
          function sendResponse(ack, data, error) {
            return promise_ZalgoPromise.flush().then(function() {
              if (!message.fireAndForget && !isWindowClosed(source)) try {
                return send_sendMessage(source, origin, {
                  id: uniqueID(),
                  origin: getDomain(window),
                  type: "postrobot_message_response",
                  hash: message.hash,
                  name: message.name,
                  ack,
                  data,
                  error
                }, {
                  on,
                  send
                });
              } catch (err) {
                throw new Error("Send response message failed for " + logName + " in " + getDomain() + "\n\n" + stringifyError(err));
              }
            });
          }
          return promise_ZalgoPromise.all([promise_ZalgoPromise.flush().then(function() {
            if (!message.fireAndForget && !isWindowClosed(source)) try {
              return send_sendMessage(source, origin, {
                id: uniqueID(),
                origin: getDomain(window),
                type: "postrobot_message_ack",
                hash: message.hash,
                name: message.name
              }, {
                on,
                send
              });
            } catch (err) {
              throw new Error("Send ack message failed for " + logName + " in " + getDomain() + "\n\n" + stringifyError(err));
            }
          }), promise_ZalgoPromise.try(function() {
            if (!options) throw new Error("No handler found for post message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
            if (!matchDomain(options.domain, origin)) throw new Error("Request origin " + origin + " does not match domain " + options.domain.toString());
            return options.handler({
              source,
              origin,
              data: message.data
            });
          }).then(function(data) {
            return sendResponse("success", data);
          }, function(error) {
            return sendResponse("error", null, error);
          })]).then(src_util_noop).catch(function(err) {
            if (options && options.handleError) return options.handleError(err);
            throw err;
          });
        }
        function handleAck(source, origin, message) {
          if (!isResponseListenerErrored(message.hash)) {
            var options = getResponseListener(message.hash);
            if (!options) throw new Error("No handler found for post message ack for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
            try {
              if (!matchDomain(options.domain, origin)) throw new Error("Ack origin " + origin + " does not match domain " + options.domain.toString());
              if (source !== options.win) throw new Error("Ack source does not match registered window");
            } catch (err) {
              options.promise.reject(err);
            }
            options.ack = true;
          }
        }
        function handleResponse(source, origin, message) {
          if (!isResponseListenerErrored(message.hash)) {
            var options = getResponseListener(message.hash);
            if (!options) throw new Error("No handler found for post message response for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
            if (!matchDomain(options.domain, origin)) throw new Error("Response origin " + origin + " does not match domain " + (pattern = options.domain, Array.isArray(pattern) ? "(" + pattern.join(" | ") + ")" : isRegex(pattern) ? "RegExp(" + pattern.toString() : pattern.toString()));
            var pattern;
            if (source !== options.win) throw new Error("Response source does not match registered window");
            deleteResponseListener(message.hash);
            "error" === message.ack ? options.promise.reject(message.error) : "success" === message.ack && options.promise.resolve({
              source,
              origin,
              data: message.data
            });
          }
        }
        function receive_receiveMessage(event, _ref2) {
          var on = _ref2.on, send = _ref2.send;
          var receivedMessages = globalStore("receivedMessages");
          try {
            if (!window || window.closed || !event.source) return;
          } catch (err) {
            return;
          }
          var source = event.source, origin = event.origin;
          var messages = function(message2, source2, origin2, _ref) {
            var on2 = _ref.on, send2 = _ref.send;
            var parsedMessage;
            try {
              parsedMessage = deserializeMessage(source2, origin2, message2, {
                on: on2,
                send: send2
              });
            } catch (err) {
              return;
            }
            if (parsedMessage && "object" == typeof parsedMessage && null !== parsedMessage) {
              var parseMessages = parsedMessage.__post_robot_10_0_42__;
              if (Array.isArray(parseMessages)) return parseMessages;
            }
          }(event.data, source, origin, {
            on,
            send
          });
          if (messages) {
            markWindowKnown(source);
            for (var _i2 = 0; _i2 < messages.length; _i2++) {
              var message = messages[_i2];
              if (receivedMessages.has(message.id)) return;
              receivedMessages.set(message.id, true);
              if (isWindowClosed(source) && !message.fireAndForget) return;
              0 === message.origin.indexOf("file:") && (origin = "file://");
              try {
                "postrobot_message_request" === message.type ? handleRequest(source, origin, message, {
                  on,
                  send
                }) : "postrobot_message_response" === message.type ? handleResponse(source, origin, message) : "postrobot_message_ack" === message.type && handleAck(source, origin, message);
              } catch (err) {
                setTimeout(function() {
                  throw err;
                }, 0);
              }
            }
          }
        }
        function on_on(name, options, handler) {
          if (!name) throw new Error("Expected name");
          if ("function" == typeof (options = options || {})) {
            handler = options;
            options = {};
          }
          if (!handler) throw new Error("Expected handler");
          (options = options || {}).name = name;
          options.handler = handler || options.handler;
          var win = options.window;
          var domain = options.domain;
          var requestListener = function addRequestListener(_ref4, listener) {
            var name2 = _ref4.name, win2 = _ref4.win, domain2 = _ref4.domain;
            var requestListeners = windowStore("requestListeners");
            if (!name2 || "string" != typeof name2) throw new Error("Name required to add request listener");
            if (Array.isArray(win2)) {
              var listenersCollection = [];
              for (var _i8 = 0, _win2 = win2; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({
                name: name2,
                domain: domain2,
                win: _win2[_i8]
              }, listener));
              return {
                cancel: function() {
                  for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();
                }
              };
            }
            if (Array.isArray(domain2)) {
              var _listenersCollection = [];
              for (var _i12 = 0, _domain2 = domain2; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({
                name: name2,
                win: win2,
                domain: _domain2[_i12]
              }, listener));
              return {
                cancel: function() {
                  for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();
                }
              };
            }
            var existingListener = getRequestListener({
              name: name2,
              win: win2,
              domain: domain2
            });
            win2 && "*" !== win2 || (win2 = getWildcard());
            domain2 = domain2 || "*";
            if (existingListener) throw win2 && domain2 ? new Error("Request listener already exists for " + name2 + " on domain " + domain2.toString() + " for " + (win2 === getWildcard() ? "wildcard" : "specified") + " window") : win2 ? new Error("Request listener already exists for " + name2 + " for " + (win2 === getWildcard() ? "wildcard" : "specified") + " window") : domain2 ? new Error("Request listener already exists for " + name2 + " on domain " + domain2.toString()) : new Error("Request listener already exists for " + name2);
            var nameListeners = requestListeners.getOrSet(win2, function() {
              return {};
            });
            var domainListeners = util_getOrSet(nameListeners, name2, function() {
              return {};
            });
            var strDomain = domain2.toString();
            var regexListeners;
            var regexListener;
            util_isRegex(domain2) ? (regexListeners = util_getOrSet(domainListeners, "__domain_regex__", function() {
              return [];
            })).push(regexListener = {
              regex: domain2,
              listener
            }) : domainListeners[strDomain] = listener;
            return {
              cancel: function() {
                delete domainListeners[strDomain];
                if (regexListener) {
                  regexListeners.splice(regexListeners.indexOf(regexListener, 1));
                  regexListeners.length || delete domainListeners.__domain_regex__;
                }
                Object.keys(domainListeners).length || delete nameListeners[name2];
                win2 && !Object.keys(nameListeners).length && requestListeners.del(win2);
              }
            };
          }({
            name,
            win,
            domain
          }, {
            handler: options.handler,
            handleError: options.errorHandler || function(err) {
              throw err;
            },
            window: win,
            domain: domain || "*",
            name
          });
          return {
            cancel: function() {
              requestListener.cancel();
            }
          };
        }
        var send_send = function send(win, name, data, options) {
          var domainMatcher = (options = options || {}).domain || "*";
          var responseTimeout = options.timeout || -1;
          var childTimeout = options.timeout || 5e3;
          var fireAndForget = options.fireAndForget || false;
          return promise_ZalgoPromise.try(function() {
            !function(name2, win2, domain) {
              if (!name2) throw new Error("Expected name");
              if (domain && "string" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError("Can not send " + name2 + ". Expected domain " + JSON.stringify(domain) + " to be a string, array, or regex");
              if (isWindowClosed(win2)) throw new Error("Can not send " + name2 + ". Target window is closed");
            }(name, win, domainMatcher);
            if (function(parent, child) {
              var actualParent = getAncestor(child);
              if (actualParent) return actualParent === parent;
              if (child === parent) return false;
              if (getTop(child) === child) return false;
              for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return true;
              return false;
            }(window, win)) return function(win2, timeout, name2) {
              void 0 === timeout && (timeout = 5e3);
              void 0 === name2 && (name2 = "Window");
              var promise = function(win3) {
                return windowStore("helloPromises").getOrSet(win3, function() {
                  return new promise_ZalgoPromise();
                });
              }(win2);
              -1 !== timeout && (promise = promise.timeout(timeout, new Error(name2 + " did not load after " + timeout + "ms")));
              return promise;
            }(win, childTimeout);
          }).then(function(_temp) {
            return function(win2, targetDomain, actualDomain, _ref) {
              var send2 = _ref.send;
              return promise_ZalgoPromise.try(function() {
                return "string" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try(function() {
                  return actualDomain || sayHello(win2, {
                    send: send2
                  }).then(function(_ref2) {
                    return _ref2.domain;
                  });
                }).then(function(normalizedDomain) {
                  if (!matchDomain(targetDomain, targetDomain)) throw new Error("Domain " + stringify(targetDomain) + " does not match " + stringify(targetDomain));
                  return normalizedDomain;
                });
              });
            }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {
              send
            });
          }).then(function(targetDomain) {
            var domain = targetDomain;
            var logName = "postrobot_method" === name && data && "string" == typeof data.name ? data.name + "()" : name;
            var promise = new promise_ZalgoPromise();
            var hash = name + "_" + uniqueID();
            if (!fireAndForget) {
              var responseListener = {
                name,
                win,
                domain,
                promise
              };
              !function(hash2, listener) {
                globalStore("responseListeners").set(hash2, listener);
              }(hash, responseListener);
              var reqPromises = windowStore("requestPromises").getOrSet(win, function() {
                return [];
              });
              reqPromises.push(promise);
              promise.catch(function() {
                !function(hash2) {
                  globalStore("erroredResponseListeners").set(hash2, true);
                }(hash);
                deleteResponseListener(hash);
              });
              var totalAckTimeout = function(win2) {
                return windowStore("knownWindows").get(win2, false);
              }(win) ? 1e4 : 2e3;
              var totalResTimeout = responseTimeout;
              var ackTimeout = totalAckTimeout;
              var resTimeout = totalResTimeout;
              var interval = safeInterval(function() {
                if (isWindowClosed(win)) return promise.reject(new Error("Window closed for " + name + " before " + (responseListener.ack ? "response" : "ack")));
                if (responseListener.cancelled) return promise.reject(new Error("Response listener was cancelled for " + name));
                ackTimeout = Math.max(ackTimeout - 500, 0);
                -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));
                return responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout ? promise.reject(new Error("No response for postMessage " + logName + " in " + getDomain() + " in " + totalResTimeout + "ms")) : void 0 : promise.reject(new Error("No ack for postMessage " + logName + " in " + getDomain() + " in " + totalAckTimeout + "ms"));
              }, 500);
              promise.finally(function() {
                interval.cancel();
                reqPromises.splice(reqPromises.indexOf(promise, 1));
              }).catch(src_util_noop);
            }
            return send_sendMessage(win, domain, {
              id: uniqueID(),
              origin: getDomain(window),
              type: "postrobot_message_request",
              hash,
              name,
              data,
              fireAndForget
            }, {
              on: on_on,
              send
            }).then(function() {
              return fireAndForget ? promise.resolve() : promise;
            }, function(err) {
              throw new Error("Send request message failed for " + logName + " in " + getDomain() + "\n\n" + stringifyError(err));
            });
          });
        };
        function setup_serializeMessage(destination, domain, obj) {
          return serializeMessage(destination, domain, obj, {
            on: on_on,
            send: send_send
          });
        }
        function setup_deserializeMessage(source, origin, message) {
          return deserializeMessage(source, origin, message, {
            on: on_on,
            send: send_send
          });
        }
        function setup_toProxyWindow(win) {
          return window_ProxyWindow.toProxyWindow(win, {
            send: send_send
          });
        }
        function lib_global_getGlobal(win) {
          void 0 === win && (win = window);
          if (!isSameDomain(win)) throw new Error("Can not get global for window on different domain");
          win.__zoid_9_0_63__ || (win.__zoid_9_0_63__ = {});
          return win.__zoid_9_0_63__;
        }
        function getProxyObject(obj) {
          return {
            get: function() {
              var _this = this;
              return promise_ZalgoPromise.try(function() {
                if (_this.source && _this.source !== window) throw new Error("Can not call get on proxy object from a remote window");
                return obj;
              });
            }
          };
        }
        var PROP_TYPE = {
          STRING: "string",
          OBJECT: "object",
          FUNCTION: "function",
          BOOLEAN: "boolean",
          NUMBER: "number",
          ARRAY: "array"
        };
        var PROP_SERIALIZATION = {
          JSON: "json",
          DOTIFY: "dotify",
          BASE64: "base64"
        };
        var CONTEXT = WINDOW_TYPE;
        var EVENT2 = {
          RENDER: "zoid-render",
          RENDERED: "zoid-rendered",
          DISPLAY: "zoid-display",
          ERROR: "zoid-error",
          CLOSE: "zoid-close",
          DESTROY: "zoid-destroy",
          PROPS: "zoid-props",
          RESIZE: "zoid-resize",
          FOCUS: "zoid-focus"
        };
        function normalizeChildProp(propsDef, props, key, value, helpers) {
          if (!propsDef.hasOwnProperty(key)) return value;
          var prop = propsDef[key];
          return "function" == typeof prop.childDecorate ? prop.childDecorate({
            value,
            uid: helpers.uid,
            close: helpers.close,
            focus: helpers.focus,
            onError: helpers.onError,
            onProps: helpers.onProps,
            resize: helpers.resize,
            getParent: helpers.getParent,
            getParentDomain: helpers.getParentDomain,
            show: helpers.show,
            hide: helpers.hide
          }) : value;
        }
        function parseChildWindowName(windowName) {
          return inlineMemoize(parseChildWindowName, function() {
            if (!windowName) throw new Error("No window name");
            var _windowName$split = windowName.split("__"), zoidcomp = _windowName$split[1], name = _windowName$split[2], encodedPayload = _windowName$split[3];
            if ("zoid" !== zoidcomp) throw new Error("Window not rendered by zoid - got " + zoidcomp);
            if (!name) throw new Error("Expected component name");
            if (!encodedPayload) throw new Error("Expected encoded payload");
            try {
              return JSON.parse(function(str) {
                if ("function" == typeof atob) return decodeURIComponent([].map.call(atob(str), function(c) {
                  return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(""));
                if ("undefined" != typeof Buffer) return Buffer.from(str, "base64").toString("utf8");
                throw new Error("Can not find window.atob or Buffer");
              }(encodedPayload));
            } catch (err) {
              throw new Error("Can not decode window name payload: " + encodedPayload + ": " + stringifyError(err));
            }
          }, [windowName]);
        }
        function getChildPayload() {
          try {
            return parseChildWindowName(window.name);
          } catch (err) {
          }
        }
        function child_focus() {
          return promise_ZalgoPromise.try(function() {
            window.focus();
          });
        }
        function child_destroy() {
          return promise_ZalgoPromise.try(function() {
            window.close();
          });
        }
        function props_getQueryParam(prop, key, value) {
          return promise_ZalgoPromise.try(function() {
            return "function" == typeof prop.queryParam ? prop.queryParam({
              value
            }) : "string" == typeof prop.queryParam ? prop.queryParam : key;
          });
        }
        function getQueryValue(prop, key, value) {
          return promise_ZalgoPromise.try(function() {
            return "function" == typeof prop.queryValue && isDefined(value) ? prop.queryValue({
              value
            }) : value;
          });
        }
        function parentComponent(options, overrides, parentWin) {
          void 0 === overrides && (overrides = {});
          void 0 === parentWin && (parentWin = window);
          var propsDef = options.propsDef, containerTemplate = options.containerTemplate, prerenderTemplate = options.prerenderTemplate, tag = options.tag, name = options.name, attributes = options.attributes, dimensions = options.dimensions, autoResize = options.autoResize, url = options.url, domainMatch = options.domain;
          var initPromise = new promise_ZalgoPromise();
          var handledErrors = [];
          var clean = cleanup();
          var state = {};
          var internalState = {
            visible: true
          };
          var event = overrides.event ? overrides.event : (triggered = {}, handlers = {}, {
            on: function(eventName, handler) {
              var handlerList = handlers[eventName] = handlers[eventName] || [];
              handlerList.push(handler);
              var cancelled = false;
              return {
                cancel: function() {
                  if (!cancelled) {
                    cancelled = true;
                    handlerList.splice(handlerList.indexOf(handler), 1);
                  }
                }
              };
            },
            once: function(eventName, handler) {
              var listener = this.on(eventName, function() {
                listener.cancel();
                handler();
              });
              return listener;
            },
            trigger: function(eventName) {
              for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];
              var handlerList = handlers[eventName];
              var promises = [];
              if (handlerList) {
                var _loop = function(_i22) {
                  var handler = handlerList[_i22];
                  promises.push(promise_ZalgoPromise.try(function() {
                    return handler.apply(void 0, args);
                  }));
                };
                for (var _i2 = 0; _i2 < handlerList.length; _i2++) _loop(_i2);
              }
              return promise_ZalgoPromise.all(promises).then(src_util_noop);
            },
            triggerOnce: function(eventName) {
              if (triggered[eventName]) return promise_ZalgoPromise.resolve();
              triggered[eventName] = true;
              for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) args[_key4 - 1] = arguments[_key4];
              return this.trigger.apply(this, [eventName].concat(args));
            },
            reset: function() {
              handlers = {};
            }
          });
          var triggered, handlers;
          var props = overrides.props ? overrides.props : {};
          var currentProxyWin;
          var currentProxyContainer;
          var childComponent;
          var onErrorOverride = overrides.onError;
          var getProxyContainerOverride = overrides.getProxyContainer;
          var showOverride = overrides.show;
          var hideOverride = overrides.hide;
          var closeOverride = overrides.close;
          var renderContainerOverride = overrides.renderContainer;
          var getProxyWindowOverride = overrides.getProxyWindow;
          var setProxyWinOverride = overrides.setProxyWin;
          var openFrameOverride = overrides.openFrame;
          var openPrerenderFrameOverride = overrides.openPrerenderFrame;
          var prerenderOverride = overrides.prerender;
          var openOverride = overrides.open;
          var openPrerenderOverride = overrides.openPrerender;
          var watchForUnloadOverride = overrides.watchForUnload;
          var getInternalStateOverride = overrides.getInternalState;
          var setInternalStateOverride = overrides.setInternalState;
          var getPropsForChild = function(domain) {
            var result = {};
            for (var _i2 = 0, _Object$keys2 = Object.keys(props); _i2 < _Object$keys2.length; _i2++) {
              var key = _Object$keys2[_i2];
              var prop = propsDef[key];
              prop && false === prop.sendToChild || prop && prop.sameDomain && !matchDomain(domain, getDomain(window)) || (result[key] = props[key]);
            }
            return promise_ZalgoPromise.hash(result);
          };
          var getInternalState = function() {
            return promise_ZalgoPromise.try(function() {
              return getInternalStateOverride ? getInternalStateOverride() : internalState;
            });
          };
          var setInternalState = function(newInternalState) {
            return promise_ZalgoPromise.try(function() {
              return setInternalStateOverride ? setInternalStateOverride(newInternalState) : internalState = _extends({}, internalState, newInternalState);
            });
          };
          var getProxyWindow = function() {
            return getProxyWindowOverride ? getProxyWindowOverride() : promise_ZalgoPromise.try(function() {
              var windowProp = props.window;
              if (windowProp) {
                var _proxyWin = setup_toProxyWindow(windowProp);
                clean.register(function() {
                  return windowProp.close();
                });
                return _proxyWin;
              }
              return new window_ProxyWindow({
                send: send_send
              });
            });
          };
          var getProxyContainer = function(container) {
            return getProxyContainerOverride ? getProxyContainerOverride(container) : promise_ZalgoPromise.try(function() {
              return elementReady(container);
            }).then(function(containerElement) {
              isShadowElement(containerElement) && (containerElement = function(element) {
                var shadowHost = function(element2) {
                  var shadowRoot = function(element3) {
                    for (; element3.parentNode; ) element3 = element3.parentNode;
                    if (isShadowElement(element3)) return element3;
                  }(element2);
                  if (shadowRoot.host) return shadowRoot.host;
                }(element);
                if (!shadowHost) throw new Error("Element is not in shadow dom");
                if (isShadowElement(shadowHost)) throw new Error("Host element is also in shadow dom");
                var slotName = "shadow-slot-" + uniqueID();
                var slot = document.createElement("slot");
                slot.setAttribute("name", slotName);
                element.appendChild(slot);
                var slotProvider = document.createElement("div");
                slotProvider.setAttribute("slot", slotName);
                shadowHost.appendChild(slotProvider);
                return slotProvider;
              }(containerElement));
              return getProxyObject(containerElement);
            });
          };
          var setProxyWin = function(proxyWin) {
            return setProxyWinOverride ? setProxyWinOverride(proxyWin) : promise_ZalgoPromise.try(function() {
              currentProxyWin = proxyWin;
            });
          };
          var show = function() {
            return showOverride ? showOverride() : promise_ZalgoPromise.hash({
              setState: setInternalState({
                visible: true
              }),
              showElement: currentProxyContainer ? currentProxyContainer.get().then(showElement) : null
            }).then(src_util_noop);
          };
          var hide = function() {
            return hideOverride ? hideOverride() : promise_ZalgoPromise.hash({
              setState: setInternalState({
                visible: false
              }),
              showElement: currentProxyContainer ? currentProxyContainer.get().then(hideElement) : null
            }).then(src_util_noop);
          };
          var getUrl = function() {
            return "function" == typeof url ? url({
              props
            }) : url;
          };
          var getAttributes = function() {
            return "function" == typeof attributes ? attributes({
              props
            }) : attributes;
          };
          var getChildDomain = function() {
            return domainMatch && "string" == typeof domainMatch ? domainMatch : getDomainFromUrl(getUrl());
          };
          var getDomainMatcher = function() {
            return domainMatch && util_isRegex(domainMatch) ? domainMatch : getChildDomain();
          };
          var openFrame = function(context, _ref) {
            var windowName = _ref.windowName;
            return openFrameOverride ? openFrameOverride(context, {
              windowName
            }) : promise_ZalgoPromise.try(function() {
              if (context === CONTEXT.IFRAME) return getProxyObject(dom_iframe({
                attributes: _extends({
                  name: windowName,
                  title: name
                }, getAttributes().iframe)
              }));
            });
          };
          var openPrerenderFrame = function(context) {
            return openPrerenderFrameOverride ? openPrerenderFrameOverride(context) : promise_ZalgoPromise.try(function() {
              if (context === CONTEXT.IFRAME) return getProxyObject(dom_iframe({
                attributes: _extends({
                  name: "__zoid_prerender_frame__" + name + "_" + uniqueID() + "__",
                  title: "prerender__" + name
                }, getAttributes().iframe)
              }));
            });
          };
          var openPrerender = function(context, proxyWin, proxyPrerenderFrame) {
            return openPrerenderOverride ? openPrerenderOverride(context, proxyWin, proxyPrerenderFrame) : promise_ZalgoPromise.try(function() {
              if (context === CONTEXT.IFRAME) {
                if (!proxyPrerenderFrame) throw new Error("Expected proxy frame to be passed");
                return proxyPrerenderFrame.get().then(function(prerenderFrame) {
                  clean.register(function() {
                    return destroyElement(prerenderFrame);
                  });
                  return awaitFrameWindow(prerenderFrame).then(function(prerenderFrameWindow) {
                    return assertSameDomain(prerenderFrameWindow);
                  }).then(function(win) {
                    return setup_toProxyWindow(win);
                  });
                });
              }
              throw new Error("No render context available for " + context);
            });
          };
          var focus = function() {
            return promise_ZalgoPromise.try(function() {
              if (currentProxyWin) return promise_ZalgoPromise.all([event.trigger(EVENT2.FOCUS), currentProxyWin.focus()]).then(src_util_noop);
            });
          };
          var getWindowRef = function(target, domain, uid, context) {
            if (domain === getDomain(window)) {
              var global = lib_global_getGlobal(window);
              global.windows = global.windows || {};
              global.windows[uid] = window;
              clean.register(function() {
                delete global.windows[uid];
              });
              return {
                type: "global",
                uid
              };
            }
            return context === CONTEXT.POPUP ? {
              type: "opener"
            } : {
              type: "parent",
              distance: getDistanceFromTop(window)
            };
          };
          var initChild = function(childExports) {
            return promise_ZalgoPromise.try(function() {
              childComponent = childExports;
              initPromise.resolve();
              clean.register(function() {
                return childExports.close.fireAndForget().catch(src_util_noop);
              });
            });
          };
          var resize = function(_ref2) {
            var width = _ref2.width, height = _ref2.height;
            return promise_ZalgoPromise.try(function() {
              event.trigger(EVENT2.RESIZE, {
                width,
                height
              });
            });
          };
          var destroy2 = function(err) {
            return promise_ZalgoPromise.try(function() {
              return event.trigger(EVENT2.DESTROY);
            }).catch(src_util_noop).then(function() {
              return clean.all(err);
            }).then(function() {
              initPromise.asyncReject(err || new Error("Component destroyed"));
            });
          };
          var close = memoize(function(err) {
            return promise_ZalgoPromise.try(function() {
              if (closeOverride) {
                if (isWindowClosed(closeOverride.__source__)) return;
                return closeOverride();
              }
              return promise_ZalgoPromise.try(function() {
                return event.trigger(EVENT2.CLOSE);
              }).then(function() {
                return destroy2(err || new Error("Component closed"));
              });
            });
          });
          var open = function(context, _ref3) {
            var proxyWin = _ref3.proxyWin, proxyFrame = _ref3.proxyFrame;
            return openOverride ? openOverride(context, {
              proxyWin,
              proxyFrame,
              windowName: _ref3.windowName
            }) : promise_ZalgoPromise.try(function() {
              if (context === CONTEXT.IFRAME) {
                if (!proxyFrame) throw new Error("Expected proxy frame to be passed");
                return proxyFrame.get().then(function(frame) {
                  return awaitFrameWindow(frame).then(function(win) {
                    clean.register(function() {
                      return destroyElement(frame);
                    });
                    clean.register(function() {
                      return function(win2) {
                        for (var _i2 = 0, _requestPromises$get2 = windowStore("requestPromises").get(win2, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error("Window " + (isWindowClosed(win2) ? "closed" : "cleaned up") + " before response")).catch(src_util_noop);
                      }(win);
                    });
                    return win;
                  });
                });
              }
              throw new Error("No render context available for " + context);
            }).then(function(win) {
              proxyWin.setWindow(win, {
                send: send_send
              });
              return proxyWin;
            });
          };
          var watchForUnload = function() {
            return promise_ZalgoPromise.try(function() {
              var unloadWindowListener = addEventListener(window, "unload", once2(function() {
                destroy2(new Error("Window navigated away"));
              }));
              var closeParentWindowListener = onCloseWindow(parentWin, destroy2, 3e3);
              clean.register(closeParentWindowListener.cancel);
              clean.register(unloadWindowListener.cancel);
              if (watchForUnloadOverride) return watchForUnloadOverride();
            });
          };
          var checkWindowClose = function(proxyWin) {
            var closed = false;
            return proxyWin.isClosed().then(function(isClosed) {
              if (isClosed) {
                closed = true;
                return close(new Error("Detected component window close"));
              }
              return promise_ZalgoPromise.delay(200).then(function() {
                return proxyWin.isClosed();
              }).then(function(secondIsClosed) {
                if (secondIsClosed) {
                  closed = true;
                  return close(new Error("Detected component window close"));
                }
              });
            }).then(function() {
              return closed;
            });
          };
          var onError = function(err) {
            return onErrorOverride ? onErrorOverride(err) : promise_ZalgoPromise.try(function() {
              if (-1 === handledErrors.indexOf(err)) {
                handledErrors.push(err);
                initPromise.asyncReject(err);
                return event.trigger(EVENT2.ERROR, err);
              }
            });
          };
          initChild.onError = onError;
          var renderTemplate = function(renderer, _ref6) {
            return renderer({
              container: _ref6.container,
              context: _ref6.context,
              uid: _ref6.uid,
              doc: _ref6.doc,
              frame: _ref6.frame,
              prerenderFrame: _ref6.prerenderFrame,
              focus,
              close,
              state,
              props,
              tag,
              dimensions,
              event
            });
          };
          var prerender = function(proxyPrerenderWin, _ref7) {
            var context = _ref7.context, uid = _ref7.uid;
            return prerenderOverride ? prerenderOverride(proxyPrerenderWin, {
              context,
              uid
            }) : promise_ZalgoPromise.try(function() {
              if (prerenderTemplate) {
                var prerenderWindow = proxyPrerenderWin.getWindow();
                if (prerenderWindow && isSameDomain(prerenderWindow) && function(win) {
                  try {
                    if (!win.location.href) return true;
                    if ("about:blank" === win.location.href) return true;
                  } catch (err) {
                  }
                  return false;
                }(prerenderWindow)) {
                  var doc = (prerenderWindow = assertSameDomain(prerenderWindow)).document;
                  var el = renderTemplate(prerenderTemplate, {
                    context,
                    uid,
                    doc
                  });
                  if (el) {
                    if (el.ownerDocument !== doc) throw new Error("Expected prerender template to have been created with document from child window");
                    !function(win, el2) {
                      var tag2 = el2.tagName.toLowerCase();
                      if ("html" !== tag2) throw new Error("Expected element to be html, got " + tag2);
                      var documentElement = win.document.documentElement;
                      for (var _i6 = 0, _arrayFrom2 = arrayFrom(documentElement.children); _i6 < _arrayFrom2.length; _i6++) documentElement.removeChild(_arrayFrom2[_i6]);
                      for (var _i8 = 0, _arrayFrom4 = arrayFrom(el2.children); _i8 < _arrayFrom4.length; _i8++) documentElement.appendChild(_arrayFrom4[_i8]);
                    }(prerenderWindow, el);
                    var _autoResize$width = autoResize.width, width = void 0 !== _autoResize$width && _autoResize$width, _autoResize$height = autoResize.height, height = void 0 !== _autoResize$height && _autoResize$height, _autoResize$element = autoResize.element, element = void 0 === _autoResize$element ? "body" : _autoResize$element;
                    if ((element = getElementSafe(element, doc)) && (width || height)) {
                      var prerenderResizeListener = onResize(element, function(_ref8) {
                        resize({
                          width: width ? _ref8.width : void 0,
                          height: height ? _ref8.height : void 0
                        });
                      }, {
                        width,
                        height,
                        win: prerenderWindow
                      });
                      event.on(EVENT2.RENDERED, prerenderResizeListener.cancel);
                    }
                  }
                }
              }
            });
          };
          var renderContainer = function(proxyContainer, _ref9) {
            var proxyFrame = _ref9.proxyFrame, proxyPrerenderFrame = _ref9.proxyPrerenderFrame, context = _ref9.context, uid = _ref9.uid;
            return renderContainerOverride ? renderContainerOverride(proxyContainer, {
              proxyFrame,
              proxyPrerenderFrame,
              context,
              uid
            }) : promise_ZalgoPromise.hash({
              container: proxyContainer.get(),
              frame: proxyFrame ? proxyFrame.get() : null,
              prerenderFrame: proxyPrerenderFrame ? proxyPrerenderFrame.get() : null,
              internalState: getInternalState()
            }).then(function(_ref10) {
              var container = _ref10.container, visible = _ref10.internalState.visible;
              var innerContainer = renderTemplate(containerTemplate, {
                context,
                uid,
                container,
                frame: _ref10.frame,
                prerenderFrame: _ref10.prerenderFrame,
                doc: document
              });
              if (innerContainer) {
                visible || hideElement(innerContainer);
                appendChild(container, innerContainer);
                var containerWatcher = function(element, handler) {
                  handler = once2(handler);
                  var cancelled = false;
                  var mutationObservers = [];
                  var interval;
                  var sacrificialFrame;
                  var sacrificialFrameWin;
                  var cancel = function() {
                    cancelled = true;
                    for (var _i18 = 0; _i18 < mutationObservers.length; _i18++) mutationObservers[_i18].disconnect();
                    interval && interval.cancel();
                    sacrificialFrameWin && sacrificialFrameWin.removeEventListener("unload", elementClosed);
                    sacrificialFrame && destroyElement(sacrificialFrame);
                  };
                  var elementClosed = function() {
                    if (!cancelled) {
                      handler();
                      cancel();
                    }
                  };
                  if (isElementClosed(element)) {
                    elementClosed();
                    return {
                      cancel
                    };
                  }
                  if (window.MutationObserver) {
                    var mutationElement = element.parentElement;
                    for (; mutationElement; ) {
                      var mutationObserver = new window.MutationObserver(function() {
                        isElementClosed(element) && elementClosed();
                      });
                      mutationObserver.observe(mutationElement, {
                        childList: true
                      });
                      mutationObservers.push(mutationObserver);
                      mutationElement = mutationElement.parentElement;
                    }
                  }
                  (sacrificialFrame = document.createElement("iframe")).setAttribute("name", "__detect_close_" + uniqueID() + "__");
                  sacrificialFrame.style.display = "none";
                  awaitFrameWindow(sacrificialFrame).then(function(frameWin) {
                    (sacrificialFrameWin = assertSameDomain(frameWin)).addEventListener("unload", elementClosed);
                  });
                  element.appendChild(sacrificialFrame);
                  interval = safeInterval(function() {
                    isElementClosed(element) && elementClosed();
                  }, 1e3);
                  return {
                    cancel
                  };
                }(innerContainer, function() {
                  return close(new Error("Detected container element removed from DOM"));
                });
                clean.register(function() {
                  return containerWatcher.cancel();
                });
                clean.register(function() {
                  return destroyElement(innerContainer);
                });
                return currentProxyContainer = getProxyObject(innerContainer);
              }
            });
          };
          var getHelpers = function() {
            return {
              state,
              event,
              close,
              focus,
              resize,
              onError,
              updateProps,
              show,
              hide
            };
          };
          var setProps = function(newProps, isUpdate) {
            void 0 === isUpdate && (isUpdate = false);
            var helpers = getHelpers();
            !function(propsDef2, props2, inputProps, helpers2, isUpdate2) {
              void 0 === isUpdate2 && (isUpdate2 = false);
              extend(props2, inputProps = inputProps || {});
              var propNames = isUpdate2 ? [] : [].concat(Object.keys(propsDef2));
              for (var _i2 = 0, _Object$keys2 = Object.keys(inputProps); _i2 < _Object$keys2.length; _i2++) {
                var key = _Object$keys2[_i2];
                -1 === propNames.indexOf(key) && propNames.push(key);
              }
              var aliases = [];
              var state2 = helpers2.state, close2 = helpers2.close, focus2 = helpers2.focus, event2 = helpers2.event, onError2 = helpers2.onError;
              for (var _i4 = 0; _i4 < propNames.length; _i4++) {
                var _key = propNames[_i4];
                var propDef = propsDef2[_key];
                var value = inputProps[_key];
                if (propDef) {
                  var alias = propDef.alias;
                  if (alias) {
                    !isDefined(value) && isDefined(inputProps[alias]) && (value = inputProps[alias]);
                    aliases.push(alias);
                  }
                  propDef.value && (value = propDef.value({
                    props: props2,
                    state: state2,
                    close: close2,
                    focus: focus2,
                    event: event2,
                    onError: onError2
                  }));
                  !isDefined(value) && propDef.default && (value = propDef.default({
                    props: props2,
                    state: state2,
                    close: close2,
                    focus: focus2,
                    event: event2,
                    onError: onError2
                  }));
                  if (isDefined(value) && ("array" === propDef.type ? !Array.isArray(value) : typeof value !== propDef.type)) throw new TypeError("Prop is not of type " + propDef.type + ": " + _key);
                  props2[_key] = value;
                }
              }
              for (var _i6 = 0; _i6 < aliases.length; _i6++) delete props2[aliases[_i6]];
              for (var _i8 = 0, _Object$keys4 = Object.keys(props2); _i8 < _Object$keys4.length; _i8++) {
                var _key2 = _Object$keys4[_i8];
                var _propDef = propsDef2[_key2];
                var _value = props2[_key2];
                _propDef && isDefined(_value) && _propDef.decorate && (props2[_key2] = _propDef.decorate({
                  value: _value,
                  props: props2,
                  state: state2,
                  close: close2,
                  focus: focus2,
                  event: event2,
                  onError: onError2
                }));
              }
              for (var _i10 = 0, _Object$keys6 = Object.keys(propsDef2); _i10 < _Object$keys6.length; _i10++) {
                var _key3 = _Object$keys6[_i10];
                if (false !== propsDef2[_key3].required && !isDefined(props2[_key3])) throw new Error('Expected prop "' + _key3 + '" to be defined');
              }
            }(propsDef, props, newProps, helpers, isUpdate);
          };
          var updateProps = function(newProps) {
            setProps(newProps, true);
            return initPromise.then(function() {
              var child = childComponent;
              var proxyWin = currentProxyWin;
              if (child && proxyWin) return getPropsForChild(getDomainMatcher()).then(function(childProps) {
                return child.updateProps(childProps).catch(function(err) {
                  return checkWindowClose(proxyWin).then(function(closed) {
                    if (!closed) throw err;
                  });
                });
              });
            });
          };
          return {
            init: function() {
              !function() {
                event.on(EVENT2.RENDER, function() {
                  return props.onRender();
                });
                event.on(EVENT2.DISPLAY, function() {
                  return props.onDisplay();
                });
                event.on(EVENT2.RENDERED, function() {
                  return props.onRendered();
                });
                event.on(EVENT2.CLOSE, function() {
                  return props.onClose();
                });
                event.on(EVENT2.DESTROY, function() {
                  return props.onDestroy();
                });
                event.on(EVENT2.RESIZE, function() {
                  return props.onResize();
                });
                event.on(EVENT2.FOCUS, function() {
                  return props.onFocus();
                });
                event.on(EVENT2.PROPS, function(newProps) {
                  return props.onProps(newProps);
                });
                event.on(EVENT2.ERROR, function(err) {
                  return props && props.onError ? props.onError(err) : initPromise.reject(err).then(function() {
                    setTimeout(function() {
                      throw err;
                    }, 1);
                  });
                });
                clean.register(event.reset);
              }();
            },
            render: function(target, container, context) {
              return promise_ZalgoPromise.try(function() {
                var uid = "zoid-" + tag + "-" + uniqueID();
                var domain = getDomainMatcher();
                var childDomain = getChildDomain();
                !function(target2, domain2, container2) {
                  if (target2 !== window) {
                    if (!isSameTopWindow(window, target2)) throw new Error("Can only renderTo an adjacent frame");
                    var origin = getDomain();
                    if (!matchDomain(domain2, origin) && !isSameDomain(target2)) throw new Error("Can not render remotely to " + domain2.toString() + " - can only render to " + origin);
                    if (container2 && "string" != typeof container2) throw new Error("Container passed to renderTo must be a string selector, got " + typeof container2 + " }");
                  }
                }(target, domain, container);
                var delegatePromise = promise_ZalgoPromise.try(function() {
                  if (target !== window) return function(context2, target2) {
                    var delegateProps = {};
                    for (var _i4 = 0, _Object$keys4 = Object.keys(props); _i4 < _Object$keys4.length; _i4++) {
                      var propName = _Object$keys4[_i4];
                      var propDef = propsDef[propName];
                      propDef && propDef.allowDelegate && (delegateProps[propName] = props[propName]);
                    }
                    var childOverridesPromise = send_send(target2, "zoid_delegate_" + name, {
                      overrides: {
                        props: delegateProps,
                        event,
                        close,
                        onError,
                        getInternalState,
                        setInternalState
                      }
                    }).then(function(_ref11) {
                      var parentComp = _ref11.data.parent;
                      clean.register(function(err) {
                        if (!isWindowClosed(target2)) return parentComp.destroy(err);
                      });
                      return parentComp.getDelegateOverrides();
                    }).catch(function(err) {
                      throw new Error("Unable to delegate rendering. Possibly the component is not loaded in the target window.\n\n" + stringifyError(err));
                    });
                    getProxyContainerOverride = function() {
                      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                      return childOverridesPromise.then(function(childOverrides) {
                        return childOverrides.getProxyContainer.apply(childOverrides, args);
                      });
                    };
                    renderContainerOverride = function() {
                      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                      return childOverridesPromise.then(function(childOverrides) {
                        return childOverrides.renderContainer.apply(childOverrides, args);
                      });
                    };
                    showOverride = function() {
                      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                      return childOverridesPromise.then(function(childOverrides) {
                        return childOverrides.show.apply(childOverrides, args);
                      });
                    };
                    hideOverride = function() {
                      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
                      return childOverridesPromise.then(function(childOverrides) {
                        return childOverrides.hide.apply(childOverrides, args);
                      });
                    };
                    watchForUnloadOverride = function() {
                      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];
                      return childOverridesPromise.then(function(childOverrides) {
                        return childOverrides.watchForUnload.apply(childOverrides, args);
                      });
                    };
                    if (context2 === CONTEXT.IFRAME) {
                      getProxyWindowOverride = function() {
                        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];
                        return childOverridesPromise.then(function(childOverrides) {
                          return childOverrides.getProxyWindow.apply(childOverrides, args);
                        });
                      };
                      openFrameOverride = function() {
                        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) args[_key7] = arguments[_key7];
                        return childOverridesPromise.then(function(childOverrides) {
                          return childOverrides.openFrame.apply(childOverrides, args);
                        });
                      };
                      openPrerenderFrameOverride = function() {
                        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) args[_key8] = arguments[_key8];
                        return childOverridesPromise.then(function(childOverrides) {
                          return childOverrides.openPrerenderFrame.apply(childOverrides, args);
                        });
                      };
                      prerenderOverride = function() {
                        for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) args[_key9] = arguments[_key9];
                        return childOverridesPromise.then(function(childOverrides) {
                          return childOverrides.prerender.apply(childOverrides, args);
                        });
                      };
                      openOverride = function() {
                        for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) args[_key10] = arguments[_key10];
                        return childOverridesPromise.then(function(childOverrides) {
                          return childOverrides.open.apply(childOverrides, args);
                        });
                      };
                      openPrerenderOverride = function() {
                        for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) args[_key11] = arguments[_key11];
                        return childOverridesPromise.then(function(childOverrides) {
                          return childOverrides.openPrerender.apply(childOverrides, args);
                        });
                      };
                    }
                    return childOverridesPromise;
                  }(context, target);
                });
                var windowProp = props.window;
                var watchForUnloadPromise = watchForUnload();
                var buildUrlPromise = function(propsDef2, props2) {
                  var params = {};
                  var keys = Object.keys(props2);
                  return promise_ZalgoPromise.all(keys.map(function(key) {
                    var prop = propsDef2[key];
                    if (prop) return promise_ZalgoPromise.resolve().then(function() {
                      var value = props2[key];
                      if (value && prop.queryParam) return value;
                    }).then(function(value) {
                      if (null != value) return promise_ZalgoPromise.all([props_getQueryParam(prop, key, value), getQueryValue(prop, 0, value)]).then(function(_ref) {
                        var queryParam = _ref[0], queryValue = _ref[1];
                        var result;
                        if ("boolean" == typeof queryValue) result = queryValue.toString();
                        else if ("string" == typeof queryValue) result = queryValue.toString();
                        else if ("object" == typeof queryValue && null !== queryValue) {
                          if (prop.serialization === PROP_SERIALIZATION.JSON) result = JSON.stringify(queryValue);
                          else if (prop.serialization === PROP_SERIALIZATION.BASE64) result = btoa(JSON.stringify(queryValue));
                          else if (prop.serialization === PROP_SERIALIZATION.DOTIFY || !prop.serialization) {
                            result = function dotify(obj, prefix, newobj) {
                              void 0 === prefix && (prefix = "");
                              void 0 === newobj && (newobj = {});
                              prefix = prefix ? prefix + "." : prefix;
                              for (var key2 in obj) obj.hasOwnProperty(key2) && null != obj[key2] && "function" != typeof obj[key2] && (obj[key2] && Array.isArray(obj[key2]) && obj[key2].length && obj[key2].every(function(val) {
                                return "object" != typeof val;
                              }) ? newobj["" + prefix + key2 + "[]"] = obj[key2].join(",") : obj[key2] && "object" == typeof obj[key2] ? newobj = dotify(obj[key2], "" + prefix + key2, newobj) : newobj["" + prefix + key2] = obj[key2].toString());
                              return newobj;
                            }(queryValue, key);
                            for (var _i12 = 0, _Object$keys8 = Object.keys(result); _i12 < _Object$keys8.length; _i12++) {
                              var dotkey = _Object$keys8[_i12];
                              params[dotkey] = result[dotkey];
                            }
                            return;
                          }
                        } else "number" == typeof queryValue && (result = queryValue.toString());
                        params[queryParam] = result;
                      });
                    });
                  })).then(function() {
                    return params;
                  });
                }(propsDef, props).then(function(query) {
                  return function(url2, options2) {
                    var query2 = options2.query || {};
                    var hash = options2.hash || {};
                    var originalUrl;
                    var originalHash;
                    var _url$split = url2.split("#");
                    originalHash = _url$split[1];
                    var _originalUrl$split = (originalUrl = _url$split[0]).split("?");
                    originalUrl = _originalUrl$split[0];
                    var queryString = extendQuery(_originalUrl$split[1], query2);
                    var hashString = extendQuery(originalHash, hash);
                    queryString && (originalUrl = originalUrl + "?" + queryString);
                    hashString && (originalUrl = originalUrl + "#" + hashString);
                    return originalUrl;
                  }(function(url2) {
                    if (!(domain2 = getDomainFromUrl(url2), 0 === domain2.indexOf("mock:"))) return url2;
                    var domain2;
                    throw new Error("Mock urls not supported out of test mode");
                  }(getUrl()), {
                    query
                  });
                });
                var onRenderPromise = event.trigger(EVENT2.RENDER);
                var getProxyContainerPromise = getProxyContainer(container);
                var getProxyWindowPromise = getProxyWindow();
                var buildWindowNamePromise = getProxyWindowPromise.then(function(proxyWin) {
                  return function(_temp) {
                    var _ref4 = void 0 === _temp ? {} : _temp, proxyWin2 = _ref4.proxyWin, childDomain2 = _ref4.childDomain, domain2 = _ref4.domain, context2 = (void 0 === _ref4.target && window, _ref4.context), uid2 = _ref4.uid;
                    return function(proxyWin3, childDomain3, domain3, uid3) {
                      return getPropsForChild(domain3).then(function(childProps) {
                        var value = setup_serializeMessage(proxyWin3, domain3, childProps);
                        var propRef = childDomain3 === getDomain() ? {
                          type: "uid",
                          uid: uid3
                        } : {
                          type: "raw",
                          value
                        };
                        if ("uid" === propRef.type) {
                          var global = lib_global_getGlobal(window);
                          global.props = global.props || {};
                          global.props[uid3] = value;
                          clean.register(function() {
                            delete global.props[uid3];
                          });
                        }
                        return propRef;
                      });
                    }(proxyWin2, childDomain2, domain2, uid2).then(function(propsRef) {
                      return {
                        uid: uid2,
                        context: context2,
                        tag,
                        version: "9_0_63",
                        childDomain: childDomain2,
                        parentDomain: getDomain(window),
                        parent: getWindowRef(0, childDomain2, uid2, context2),
                        props: propsRef,
                        exports: setup_serializeMessage(proxyWin2, domain2, (win = proxyWin2, {
                          init: initChild,
                          close,
                          checkClose: function() {
                            return checkWindowClose(win);
                          },
                          resize,
                          onError,
                          show,
                          hide
                        }))
                      };
                      var win;
                    });
                  }({
                    proxyWin: (_ref5 = {
                      proxyWin,
                      childDomain,
                      domain,
                      target,
                      context,
                      uid
                    }).proxyWin,
                    childDomain: _ref5.childDomain,
                    domain: _ref5.domain,
                    target: _ref5.target,
                    context: _ref5.context,
                    uid: _ref5.uid
                  }).then(function(childPayload) {
                    return "__zoid__" + name + "__" + base64encode(JSON.stringify(childPayload)) + "__";
                  });
                  var _ref5;
                });
                var openFramePromise = buildWindowNamePromise.then(function(windowName) {
                  return openFrame(context, {
                    windowName
                  });
                });
                var openPrerenderFramePromise = openPrerenderFrame(context);
                var renderContainerPromise = promise_ZalgoPromise.hash({
                  proxyContainer: getProxyContainerPromise,
                  proxyFrame: openFramePromise,
                  proxyPrerenderFrame: openPrerenderFramePromise
                }).then(function(_ref12) {
                  return renderContainer(_ref12.proxyContainer, {
                    context,
                    uid,
                    proxyFrame: _ref12.proxyFrame,
                    proxyPrerenderFrame: _ref12.proxyPrerenderFrame
                  });
                }).then(function(proxyContainer) {
                  return proxyContainer;
                });
                var openPromise = promise_ZalgoPromise.hash({
                  windowName: buildWindowNamePromise,
                  proxyFrame: openFramePromise,
                  proxyWin: getProxyWindowPromise
                }).then(function(_ref13) {
                  var proxyWin = _ref13.proxyWin;
                  return windowProp ? proxyWin : open(context, {
                    windowName: _ref13.windowName,
                    proxyWin,
                    proxyFrame: _ref13.proxyFrame
                  });
                });
                var openPrerenderPromise = promise_ZalgoPromise.hash({
                  proxyWin: openPromise,
                  proxyPrerenderFrame: openPrerenderFramePromise
                }).then(function(_ref14) {
                  return openPrerender(context, _ref14.proxyWin, _ref14.proxyPrerenderFrame);
                });
                var setStatePromise = openPromise.then(function(proxyWin) {
                  currentProxyWin = proxyWin;
                  return setProxyWin(proxyWin);
                });
                var prerenderPromise = promise_ZalgoPromise.hash({
                  proxyPrerenderWin: openPrerenderPromise,
                  state: setStatePromise
                }).then(function(_ref15) {
                  return prerender(_ref15.proxyPrerenderWin, {
                    context,
                    uid
                  });
                });
                var setWindowNamePromise = promise_ZalgoPromise.hash({
                  proxyWin: openPromise,
                  windowName: buildWindowNamePromise
                }).then(function(_ref16) {
                  if (windowProp) return _ref16.proxyWin.setName(_ref16.windowName);
                });
                var loadUrlPromise = promise_ZalgoPromise.hash({
                  proxyWin: openPromise,
                  builtUrl: buildUrlPromise,
                  windowName: setWindowNamePromise,
                  prerender: prerenderPromise
                }).then(function(_ref17) {
                  return _ref17.proxyWin.setLocation(_ref17.builtUrl);
                });
                var watchForClosePromise = openPromise.then(function(proxyWin) {
                  !function watchForClose(proxyWin2, context2) {
                    var cancelled = false;
                    clean.register(function() {
                      cancelled = true;
                    });
                    return promise_ZalgoPromise.delay(2e3).then(function() {
                      return proxyWin2.isClosed();
                    }).then(function(isClosed) {
                      return isClosed ? close(new Error("Detected " + context2 + " close")) : cancelled ? void 0 : watchForClose(proxyWin2, context2);
                    });
                  }(proxyWin, context);
                });
                var onDisplayPromise = promise_ZalgoPromise.hash({
                  container: renderContainerPromise,
                  prerender: prerenderPromise
                }).then(function() {
                  return event.trigger(EVENT2.DISPLAY);
                });
                var openBridgePromise = openPromise.then(function(proxyWin) {
                });
                var runTimeoutPromise = loadUrlPromise.then(function() {
                  return promise_ZalgoPromise.try(function() {
                    var timeout = props.timeout;
                    if (timeout) return initPromise.timeout(timeout, new Error("Loading component timed out after " + timeout + " milliseconds"));
                  });
                });
                var onRenderedPromise = initPromise.then(function() {
                  return event.trigger(EVENT2.RENDERED);
                });
                return promise_ZalgoPromise.hash({
                  initPromise,
                  buildUrlPromise,
                  onRenderPromise,
                  getProxyContainerPromise,
                  openFramePromise,
                  openPrerenderFramePromise,
                  renderContainerPromise,
                  openPromise,
                  openPrerenderPromise,
                  setStatePromise,
                  prerenderPromise,
                  loadUrlPromise,
                  buildWindowNamePromise,
                  setWindowNamePromise,
                  watchForClosePromise,
                  onDisplayPromise,
                  openBridgePromise,
                  runTimeoutPromise,
                  onRenderedPromise,
                  delegatePromise,
                  watchForUnloadPromise
                });
              }).catch(function(err) {
                return promise_ZalgoPromise.all([onError(err), destroy2(err)]).then(function() {
                  throw err;
                }, function() {
                  throw err;
                });
              }).then(src_util_noop);
            },
            destroy: destroy2,
            setProps,
            getHelpers,
            getDelegateOverrides: function() {
              return promise_ZalgoPromise.try(function() {
                return {
                  getProxyContainer,
                  show,
                  hide,
                  renderContainer,
                  getProxyWindow,
                  watchForUnload,
                  openFrame,
                  openPrerenderFrame,
                  prerender,
                  open,
                  openPrerender,
                  setProxyWin
                };
              });
            }
          };
        }
        var react = {
          register: function(tag, propsDef, init, _ref) {
            var React2 = _ref.React, ReactDOM = _ref.ReactDOM;
            return function(_React$Component) {
              _inheritsLoose(_class, _React$Component);
              function _class() {
                return _React$Component.apply(this, arguments) || this;
              }
              var _proto = _class.prototype;
              _proto.render = function() {
                return React2.createElement("div", null);
              };
              _proto.componentDidMount = function() {
                var el = ReactDOM.findDOMNode(this);
                var parent = init(extend({}, this.props));
                parent.render(el, CONTEXT.IFRAME);
                this.setState({
                  parent
                });
              };
              _proto.componentDidUpdate = function() {
                this.state && this.state.parent && this.state.parent.updateProps(extend({}, this.props)).catch(src_util_noop);
              };
              return _class;
            }(React2.Component);
          }
        };
        var vue = {
          register: function(tag, propsDef, init, Vue) {
            return Vue.component(tag, {
              render: function(createElement) {
                return createElement("div");
              },
              inheritAttrs: false,
              mounted: function() {
                var el = this.$el;
                this.parent = init(_extends({}, this.$attrs));
                this.parent.render(el, CONTEXT.IFRAME);
              },
              watch: {
                $attrs: {
                  handler: function() {
                    this.parent && this.$attrs && this.parent.updateProps(_extends({}, this.$attrs)).catch(src_util_noop);
                  },
                  deep: true
                }
              }
            });
          }
        };
        var angular = {
          register: function(tag, propsDef, init, ng) {
            return ng.module(tag, []).directive(tag.replace(/-([a-z])/g, function(g) {
              return g[1].toUpperCase();
            }), function() {
              var scope = {};
              for (var _i2 = 0, _Object$keys2 = Object.keys(propsDef); _i2 < _Object$keys2.length; _i2++) scope[_Object$keys2[_i2]] = "=";
              scope.props = "=";
              return {
                scope,
                restrict: "E",
                controller: ["$scope", "$element", function($scope, $element) {
                  function safeApply() {
                    if ("$apply" !== $scope.$root.$$phase && "$digest" !== $scope.$root.$$phase) try {
                      $scope.$apply();
                    } catch (err) {
                    }
                  }
                  var getProps = function() {
                    return replaceObject($scope.props, function(item) {
                      return "function" == typeof item ? function() {
                        var result = item.apply(this, arguments);
                        safeApply();
                        return result;
                      } : item;
                    });
                  };
                  var instance = init(getProps());
                  instance.render($element[0], CONTEXT.IFRAME);
                  $scope.$watch(function() {
                    instance.updateProps(getProps()).catch(src_util_noop);
                  });
                }]
              };
            });
          }
        };
        var angular2 = {
          register: function(tag, propsDef, init, _ref) {
            var NgModule = _ref.NgModule, ElementRef = _ref.ElementRef, NgZone = _ref.NgZone;
            var getProps = function(component) {
              return replaceObject(_extends({}, component.internalProps, component.props), function(item) {
                return "function" == typeof item ? function() {
                  var _arguments = arguments, _this = this;
                  return component.zone.run(function() {
                    return item.apply(_this, _arguments);
                  });
                } : item;
              });
            };
            var ComponentInstance = (0, _ref.Component)({
              selector: tag,
              template: "<div></div>",
              inputs: ["props"]
            }).Class({
              constructor: [ElementRef, NgZone, function(elementRef, zone) {
                this._props = {};
                this.elementRef = elementRef;
                this.zone = zone;
              }],
              ngOnInit: function() {
                var targetElement = this.elementRef.nativeElement;
                this.parent = init(getProps(this));
                this.parent.render(targetElement, CONTEXT.IFRAME);
              },
              ngDoCheck: function() {
                if (this.parent && !function(obj1, obj2) {
                  var checked = {};
                  for (var key in obj1) if (obj1.hasOwnProperty(key)) {
                    checked[key] = true;
                    if (obj1[key] !== obj2[key]) return false;
                  }
                  for (var _key in obj2) if (!checked[_key]) return false;
                  return true;
                }(this._props, this.props)) {
                  this._props = _extends({}, this.props);
                  this.parent.updateProps(getProps(this));
                }
              }
            });
            return NgModule({
              declarations: [ComponentInstance],
              exports: [ComponentInstance]
            }).Class({
              constructor: function() {
              }
            });
          }
        };
        function defaultContainerTemplate(_ref) {
          var uid = _ref.uid, frame = _ref.frame, prerenderFrame = _ref.prerenderFrame, doc = _ref.doc, props = _ref.props, event = _ref.event, _ref$dimensions = _ref.dimensions, width = _ref$dimensions.width, height = _ref$dimensions.height;
          if (frame && prerenderFrame) {
            var div = doc.createElement("div");
            div.setAttribute("id", uid);
            var style = doc.createElement("style");
            props.cspNonce && style.setAttribute("nonce", props.cspNonce);
            style.appendChild(doc.createTextNode("\n            #" + uid + " {\n                display: inline-block;\n                position: relative;\n                width: " + width + ";\n                height: " + height + ";\n            }\n\n            #" + uid + " > iframe {\n                display: inline-block;\n                position: absolute;\n                width: 100%;\n                height: 100%;\n                top: 0;\n                left: 0;\n                transition: opacity .2s ease-in-out;\n            }\n\n            #" + uid + " > iframe.zoid-invisible {\n                opacity: 0;\n            }\n\n            #" + uid + " > iframe.zoid-visible {\n                opacity: 1;\n        }\n        "));
            div.appendChild(frame);
            div.appendChild(prerenderFrame);
            div.appendChild(style);
            prerenderFrame.classList.add("zoid-visible");
            frame.classList.add("zoid-invisible");
            event.on(EVENT2.RENDERED, function() {
              prerenderFrame.classList.remove("zoid-visible");
              prerenderFrame.classList.add("zoid-invisible");
              frame.classList.remove("zoid-invisible");
              frame.classList.add("zoid-visible");
              setTimeout(function() {
                destroyElement(prerenderFrame);
              }, 1);
            });
            event.on(EVENT2.RESIZE, function(_ref2) {
              var newWidth = _ref2.width, newHeight = _ref2.height;
              "number" == typeof newWidth && (div.style.width = toCSS(newWidth));
              "number" == typeof newHeight && (div.style.height = toCSS(newHeight));
            });
            return div;
          }
        }
        function defaultPrerenderTemplate(_ref) {
          var doc = _ref.doc, props = _ref.props;
          var html = doc.createElement("html");
          var body = doc.createElement("body");
          var style = doc.createElement("style");
          var spinner = doc.createElement("div");
          spinner.classList.add("spinner");
          props.cspNonce && style.setAttribute("nonce", props.cspNonce);
          html.appendChild(body);
          body.appendChild(spinner);
          body.appendChild(style);
          style.appendChild(doc.createTextNode("\n            html, body {\n                width: 100%;\n                height: 100%;\n            }\n\n            .spinner {\n                position: fixed;\n                max-height: 60vmin;\n                max-width: 60vmin;\n                height: 40px;\n                width: 40px;\n                top: 50%;\n                left: 50%;\n                box-sizing: border-box;\n                border: 3px solid rgba(0, 0, 0, .2);\n                border-top-color: rgba(33, 128, 192, 0.8);\n                border-radius: 100%;\n                animation: rotation .7s infinite linear;\n            }\n\n            @keyframes rotation {\n                from {\n                    transform: translateX(-50%) translateY(-50%) rotate(0deg);\n                }\n                to {\n                    transform: translateX(-50%) translateY(-50%) rotate(359deg);\n                }\n            }\n        "));
          return html;
        }
        var props_defaultNoop = function() {
          return src_util_noop;
        };
        var props_decorateOnce = function(_ref) {
          return once2(_ref.value);
        };
        var cleanInstances = cleanup();
        var cleanZoid = cleanup();
        function component_component(opts) {
          var options = function(options2) {
            var tag2 = options2.tag, url = options2.url, domain = options2.domain, bridgeUrl = options2.bridgeUrl, _options$props = options2.props, propsDef2 = void 0 === _options$props ? {} : _options$props, _options$dimensions = options2.dimensions, dimensions = void 0 === _options$dimensions ? {} : _options$dimensions, _options$autoResize = options2.autoResize, autoResize = void 0 === _options$autoResize ? {} : _options$autoResize, _options$allowedParen = options2.allowedParentDomains, allowedParentDomains = void 0 === _options$allowedParen ? "*" : _options$allowedParen, _options$attributes = options2.attributes, attributes = void 0 === _options$attributes ? {} : _options$attributes, _options$defaultConte = options2.defaultContext, defaultContext2 = void 0 === _options$defaultConte ? CONTEXT.IFRAME : _options$defaultConte, _options$containerTem = options2.containerTemplate, containerTemplate = void 0 === _options$containerTem ? defaultContainerTemplate : _options$containerTem, _options$prerenderTem = options2.prerenderTemplate, prerenderTemplate = void 0 === _options$prerenderTem ? defaultPrerenderTemplate : _options$prerenderTem, validate = options2.validate, _options$eligible = options2.eligible, eligible2 = void 0 === _options$eligible ? function() {
              return {
                eligible: true
              };
            } : _options$eligible, _options$logger = options2.logger, logger = void 0 === _options$logger ? {
              info: src_util_noop
            } : _options$logger;
            var name2 = tag2.replace(/-/g, "_");
            var _dimensions$width = dimensions.width, width = void 0 === _dimensions$width ? "300px" : _dimensions$width, _dimensions$height = dimensions.height, height = void 0 === _dimensions$height ? "150px" : _dimensions$height;
            propsDef2 = _extends({}, {
              window: {
                type: "object",
                sendToChild: false,
                required: false,
                allowDelegate: true,
                validate: function(_ref2) {
                  var value = _ref2.value;
                  if (!isWindow(value) && !window_ProxyWindow.isProxyWindow(value)) throw new Error("Expected Window or ProxyWindow");
                  if (isWindow(value)) {
                    if (isWindowClosed(value)) throw new Error("Window is closed");
                    if (!isSameDomain(value)) throw new Error("Window is not same domain");
                  }
                },
                decorate: function(_ref3) {
                  return setup_toProxyWindow(_ref3.value);
                }
              },
              timeout: {
                type: "number",
                required: false,
                sendToChild: false
              },
              close: {
                type: "function",
                required: false,
                sendToChild: false,
                childDecorate: function(_ref4) {
                  return _ref4.close;
                }
              },
              focus: {
                type: "function",
                required: false,
                sendToChild: false,
                childDecorate: function(_ref5) {
                  return _ref5.focus;
                }
              },
              resize: {
                type: "function",
                required: false,
                sendToChild: false,
                childDecorate: function(_ref6) {
                  return _ref6.resize;
                }
              },
              uid: {
                type: "string",
                required: false,
                sendToChild: false,
                childDecorate: function(_ref7) {
                  return _ref7.uid;
                }
              },
              cspNonce: {
                type: "string",
                required: false
              },
              getParent: {
                type: "function",
                required: false,
                sendToChild: false,
                childDecorate: function(_ref8) {
                  return _ref8.getParent;
                }
              },
              getParentDomain: {
                type: "function",
                required: false,
                sendToChild: false,
                childDecorate: function(_ref9) {
                  return _ref9.getParentDomain;
                }
              },
              show: {
                type: "function",
                required: false,
                sendToChild: false,
                childDecorate: function(_ref10) {
                  return _ref10.show;
                }
              },
              hide: {
                type: "function",
                required: false,
                sendToChild: false,
                childDecorate: function(_ref11) {
                  return _ref11.hide;
                }
              },
              onDisplay: {
                type: "function",
                required: false,
                sendToChild: false,
                allowDelegate: true,
                default: props_defaultNoop,
                decorate: props_decorateOnce
              },
              onRendered: {
                type: "function",
                required: false,
                sendToChild: false,
                default: props_defaultNoop,
                decorate: props_decorateOnce
              },
              onRender: {
                type: "function",
                required: false,
                sendToChild: false,
                default: props_defaultNoop,
                decorate: props_decorateOnce
              },
              onClose: {
                type: "function",
                required: false,
                sendToChild: false,
                allowDelegate: true,
                default: props_defaultNoop,
                decorate: props_decorateOnce
              },
              onDestroy: {
                type: "function",
                required: false,
                sendToChild: false,
                allowDelegate: true,
                default: props_defaultNoop,
                decorate: props_decorateOnce
              },
              onResize: {
                type: "function",
                required: false,
                sendToChild: false,
                allowDelegate: true,
                default: props_defaultNoop
              },
              onFocus: {
                type: "function",
                required: false,
                sendToChild: false,
                allowDelegate: true,
                default: props_defaultNoop
              },
              onError: {
                type: "function",
                required: false,
                sendToChild: false,
                childDecorate: function(_ref12) {
                  return _ref12.onError;
                }
              },
              onProps: {
                type: "function",
                required: false,
                sendToChild: false,
                default: props_defaultNoop,
                childDecorate: function(_ref13) {
                  return _ref13.onProps;
                }
              }
            }, propsDef2);
            if (!containerTemplate) throw new Error("Container template required");
            return {
              name: name2,
              tag: tag2,
              url,
              domain,
              bridgeUrl,
              propsDef: propsDef2,
              dimensions: {
                width,
                height
              },
              autoResize,
              allowedParentDomains,
              attributes,
              defaultContext: defaultContext2,
              containerTemplate,
              prerenderTemplate,
              validate,
              logger,
              eligible: eligible2
            };
          }(opts);
          var name = options.name, tag = options.tag, defaultContext = options.defaultContext, propsDef = options.propsDef, eligible = options.eligible;
          var global = lib_global_getGlobal();
          var driverCache = {};
          var instances = [];
          var isChild = function() {
            var payload = getChildPayload();
            return Boolean(payload && payload.tag === tag && payload.childDomain === getDomain());
          };
          var registerChild = memoize(function() {
            if (isChild()) {
              if (window.xprops) {
                delete global.components[tag];
                throw new Error("Can not register " + name + " as child - child already registered");
              }
              var child = function(options2) {
                var propsDef2 = options2.propsDef, autoResize = options2.autoResize, allowedParentDomains = options2.allowedParentDomains;
                var onPropHandlers = [];
                var childPayload = getChildPayload();
                var props;
                if (!childPayload) throw new Error("No child payload found");
                if ("9_0_63" !== childPayload.version) throw new Error("Parent window has zoid version " + childPayload.version + ", child window has version 9_0_63");
                var uid = childPayload.uid, parentDomain = childPayload.parentDomain, exports2 = childPayload.exports, context = childPayload.context, propsRef = childPayload.props;
                var parentComponentWindow = function(ref) {
                  var type = ref.type;
                  if ("opener" === type) return assertExists("opener", getOpener(window));
                  if ("parent" === type && "number" == typeof ref.distance) return assertExists("parent", function(win, n) {
                    void 0 === n && (n = 1);
                    return function(win2, n2) {
                      void 0 === n2 && (n2 = 1);
                      var parent2 = win2;
                      for (var i = 0; i < n2; i++) {
                        if (!parent2) return;
                        parent2 = utils_getParent(parent2);
                      }
                      return parent2;
                    }(win, getDistanceFromTop(win) - n);
                  }(window, ref.distance));
                  if ("global" === type && ref.uid && "string" == typeof ref.uid) {
                    var uid2 = ref.uid;
                    var ancestor = getAncestor(window);
                    if (!ancestor) throw new Error("Can not find ancestor window");
                    for (var _i2 = 0, _getAllFramesInWindow2 = getAllFramesInWindow(ancestor); _i2 < _getAllFramesInWindow2.length; _i2++) {
                      var frame = _getAllFramesInWindow2[_i2];
                      if (isSameDomain(frame)) {
                        var global2 = lib_global_getGlobal(frame);
                        if (global2 && global2.windows && global2.windows[uid2]) return global2.windows[uid2];
                      }
                    }
                  }
                  throw new Error("Unable to find " + type + " parent component window");
                }(childPayload.parent);
                var parent = setup_deserializeMessage(parentComponentWindow, parentDomain, exports2);
                var show = parent.show, hide = parent.hide, close = parent.close;
                var getParent = function() {
                  return parentComponentWindow;
                };
                var getParentDomain = function() {
                  return parentDomain;
                };
                var onProps = function(handler) {
                  onPropHandlers.push(handler);
                };
                var onError = function(err) {
                  return promise_ZalgoPromise.try(function() {
                    if (parent && parent.onError) return parent.onError(err);
                    throw err;
                  });
                };
                var resize = function(_ref2) {
                  return parent.resize.fireAndForget({
                    width: _ref2.width,
                    height: _ref2.height
                  });
                };
                var setProps = function(newProps, origin, isUpdate) {
                  void 0 === isUpdate && (isUpdate = false);
                  var normalizedProps = function(parentComponentWindow2, propsDef3, props2, origin2, helpers, isUpdate2) {
                    void 0 === isUpdate2 && (isUpdate2 = false);
                    var result = {};
                    for (var _i2 = 0, _Object$keys2 = Object.keys(props2); _i2 < _Object$keys2.length; _i2++) {
                      var key = _Object$keys2[_i2];
                      var prop = propsDef3[key];
                      if (!prop || !prop.sameDomain || origin2 === getDomain(window) && isSameDomain(parentComponentWindow2)) {
                        var value = normalizeChildProp(propsDef3, 0, key, props2[key], helpers);
                        result[key] = value;
                        prop && prop.alias && !result[prop.alias] && (result[prop.alias] = value);
                      }
                    }
                    if (!isUpdate2) for (var _i42 = 0, _Object$keys4 = Object.keys(propsDef3); _i42 < _Object$keys4.length; _i42++) {
                      var _key = _Object$keys4[_i42];
                      props2.hasOwnProperty(_key) || (result[_key] = normalizeChildProp(propsDef3, 0, _key, void 0, helpers));
                    }
                    return result;
                  }(parentComponentWindow, propsDef2, newProps, origin, {
                    show,
                    hide,
                    close,
                    focus: child_focus,
                    onError,
                    resize,
                    onProps,
                    getParent,
                    getParentDomain,
                    uid
                  }, isUpdate);
                  props ? extend(props, normalizedProps) : props = normalizedProps;
                  for (var _i4 = 0; _i4 < onPropHandlers.length; _i4++) (0, onPropHandlers[_i4])(props);
                };
                var updateProps = function(newProps) {
                  return promise_ZalgoPromise.try(function() {
                    return setProps(newProps, parentDomain, true);
                  });
                };
                return {
                  init: function() {
                    return promise_ZalgoPromise.try(function() {
                      !function(allowedParentDomains2, domain) {
                        if (!matchDomain(allowedParentDomains2, domain)) throw new Error("Can not be rendered by domain: " + domain);
                      }(allowedParentDomains, parentDomain);
                      markWindowKnown(parentComponentWindow);
                      !function() {
                        window.addEventListener("beforeunload", function() {
                          parent.checkClose.fireAndForget();
                        });
                        window.addEventListener("unload", function() {
                          parent.checkClose.fireAndForget();
                        });
                        onCloseWindow(parentComponentWindow, function() {
                          child_destroy();
                        });
                      }();
                      return parent.init({
                        updateProps,
                        close: child_destroy
                      });
                    }).then(function() {
                      return (_autoResize$width = autoResize.width, width = void 0 !== _autoResize$width && _autoResize$width, _autoResize$height = autoResize.height, height = void 0 !== _autoResize$height && _autoResize$height, _autoResize$element = autoResize.element, elementReady(void 0 === _autoResize$element ? "body" : _autoResize$element).catch(src_util_noop).then(function(element) {
                        return {
                          width,
                          height,
                          element
                        };
                      })).then(function(_ref3) {
                        var width2 = _ref3.width, height2 = _ref3.height, element = _ref3.element;
                        element && (width2 || height2) && context !== CONTEXT.POPUP && onResize(element, function(_ref4) {
                          resize({
                            width: width2 ? _ref4.width : void 0,
                            height: height2 ? _ref4.height : void 0
                          });
                        }, {
                          width: width2,
                          height: height2
                        });
                      });
                      var _autoResize$width, width, _autoResize$height, height, _autoResize$element;
                    }).catch(function(err) {
                      onError(err);
                    });
                  },
                  getProps: function() {
                    if (props) return props;
                    setProps(function(parentComponentWindow2, domain, _ref) {
                      var type = _ref.type, uid2 = _ref.uid;
                      var props2;
                      if ("raw" === type) props2 = _ref.value;
                      else if ("uid" === type) {
                        if (!isSameDomain(parentComponentWindow2)) throw new Error("Parent component window is on a different domain - expected " + getDomain() + " - can not retrieve props");
                        var global2 = lib_global_getGlobal(parentComponentWindow2);
                        props2 = assertExists("props", global2 && global2.props[uid2]);
                      }
                      if (!props2) throw new Error("Could not find props");
                      return setup_deserializeMessage(parentComponentWindow2, domain, props2);
                    }(parentComponentWindow, parentDomain, propsRef), parentDomain);
                    return props;
                  }
                };
              }(options);
              child.init();
              return child;
            }
          });
          var init = function init2(props) {
            var instance;
            var _eligible = eligible({
              props: props = props || {}
            }), eligibility = _eligible.eligible, reason = _eligible.reason;
            var onDestroy = props.onDestroy;
            props.onDestroy = function() {
              instance && eligibility && instances.splice(instances.indexOf(instance), 1);
              if (onDestroy) return onDestroy.apply(void 0, arguments);
            };
            var parent = parentComponent(options);
            parent.init();
            eligibility ? parent.setProps(props) : props.onDestroy && props.onDestroy();
            cleanInstances.register(function(err) {
              parent.destroy(err || new Error("zoid destroyed all components"));
            });
            var _render = function(target, container, context) {
              return promise_ZalgoPromise.try(function() {
                if (!eligibility) {
                  var err = new Error(reason || name + " component is not eligible");
                  return parent.destroy(err).then(function() {
                    throw err;
                  });
                }
                if (!isWindow(target)) throw new Error("Must pass window to renderTo");
                return function(props2, context2) {
                  return promise_ZalgoPromise.try(function() {
                    if (props2.window) return setup_toProxyWindow(props2.window).getType();
                    if (context2) {
                      if (context2 !== CONTEXT.IFRAME && context2 !== CONTEXT.POPUP) throw new Error("Unrecognized context: " + context2);
                      return context2;
                    }
                    return defaultContext;
                  });
                }(props, context);
              }).then(function(finalContext) {
                container = function(context2, container2) {
                  if (container2) {
                    if ("string" != typeof container2 && !isElement(container2)) throw new TypeError("Expected string or element selector to be passed");
                    return container2;
                  }
                  if (context2 === CONTEXT.POPUP) return "body";
                  throw new Error("Expected element to be passed to render iframe");
                }(finalContext, container);
                return parent.render(target, container, finalContext);
              }).catch(function(err) {
                return parent.destroy(err).then(function() {
                  throw err;
                });
              });
            };
            instance = _extends({}, parent.getHelpers(), {
              isEligible: function() {
                return eligibility;
              },
              clone: function(_temp) {
                var _ref3$decorate = (void 0 === _temp ? {} : _temp).decorate;
                return init2((void 0 === _ref3$decorate ? identity : _ref3$decorate)(props));
              },
              render: function(container, context) {
                return _render(window, container, context);
              },
              renderTo: function(target, container, context) {
                return _render(target, container, context);
              }
            });
            eligibility && instances.push(instance);
            return instance;
          };
          registerChild();
          !function() {
            var allowDelegateListener = on_on("zoid_allow_delegate_" + name, function() {
              return true;
            });
            var delegateListener = on_on("zoid_delegate_" + name, function(_ref) {
              return {
                parent: parentComponent(options, _ref.data.overrides, _ref.source)
              };
            });
            cleanZoid.register(allowDelegateListener.cancel);
            cleanZoid.register(delegateListener.cancel);
          }();
          global.components = global.components || {};
          if (global.components[tag]) throw new Error("Can not register multiple components with the same tag: " + tag);
          global.components[tag] = true;
          return {
            init,
            instances,
            driver: function(driverName, dep) {
              var drivers = {
                react,
                angular,
                vue,
                angular2
              };
              if (!drivers[driverName]) throw new Error("Could not find driver for framework: " + driverName);
              driverCache[driverName] || (driverCache[driverName] = drivers[driverName].register(tag, propsDef, init, dep));
              return driverCache[driverName];
            },
            isChild,
            canRenderTo: function(win) {
              return send_send(win, "zoid_allow_delegate_" + name).then(function(_ref2) {
                return _ref2.data;
              }).catch(function() {
                return false;
              });
            },
            registerChild
          };
        }
        function create2(options) {
          !function() {
            if (!global_getGlobal().initialized) {
              global_getGlobal().initialized = true;
              on = (_ref3 = {
                on: on_on,
                send: send_send
              }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function(message) {
                return receive_receiveMessage(message, {
                  on,
                  send
                });
              };
              !function(_ref5) {
                var on2 = _ref5.on, send2 = _ref5.send;
                globalStore().getOrSet("postMessageListener", function() {
                  return addEventListener(window, "message", function(event) {
                    !function(event2, _ref4) {
                      var on3 = _ref4.on, send3 = _ref4.send;
                      promise_ZalgoPromise.try(function() {
                        var source = event2.source || event2.sourceElement;
                        var origin = event2.origin || event2.originalEvent && event2.originalEvent.origin;
                        var data = event2.data;
                        "null" === origin && (origin = "file://");
                        if (source) {
                          if (!origin) throw new Error("Post message did not have origin domain");
                          receive_receiveMessage({
                            source,
                            origin,
                            data
                          }, {
                            on: on3,
                            send: send3
                          });
                        }
                      });
                    }(event, {
                      on: on2,
                      send: send2
                    });
                  });
                });
              }({
                on: on_on,
                send: send_send
              });
              !function(_ref8) {
                var on2 = _ref8.on, send2 = _ref8.send;
                globalStore("builtinListeners").getOrSet("helloListener", function() {
                  var listener = on2("postrobot_hello", {
                    domain: "*"
                  }, function(_ref32) {
                    resolveHelloPromise(_ref32.source, {
                      domain: _ref32.origin
                    });
                    return {
                      instanceID: getInstanceID()
                    };
                  });
                  var parent = getAncestor();
                  parent && sayHello(parent, {
                    send: send2
                  }).catch(function(err) {
                  });
                  return listener;
                });
              }({
                on: on_on,
                send: send_send
              });
            }
            var _ref3, on, send, global;
          }();
          var comp = component_component(options);
          var init = function(props) {
            return comp.init(props);
          };
          init.driver = function(name, dep) {
            return comp.driver(name, dep);
          };
          init.isChild = function() {
            return comp.isChild();
          };
          init.canRenderTo = function(win) {
            return comp.canRenderTo(win);
          };
          init.instances = comp.instances;
          var child = comp.registerChild();
          child && (window.xprops = init.xprops = child.getProps());
          return init;
        }
        function destroyComponents(err) {
          var destroyPromise = cleanInstances.all(err);
          cleanInstances = cleanup();
          return destroyPromise;
        }
        var destroyAll = destroyComponents;
        function component_destroy(err) {
          destroyAll();
          delete window.__zoid_9_0_63__;
          !function() {
            !function() {
              var responseListeners = globalStore("responseListeners");
              for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {
                var hash = _responseListeners$ke2[_i2];
                var listener2 = responseListeners.get(hash);
                listener2 && (listener2.cancelled = true);
                responseListeners.del(hash);
              }
            }();
            (listener = globalStore().get("postMessageListener")) && listener.cancel();
            var listener;
            delete window.__post_robot_10_0_42__;
          }();
          return cleanZoid.all(err);
        }
      }]);
    });
  }
});

// node_modules/pluggy-connect-sdk/dist/module/pluggy-connect.js
var import_zoid_frameworks = __toESM(require_zoid_frameworks_frame());

// node_modules/pluggy-connect-sdk/dist/module/components/loader/css/index.js
var getContainerCss = ({ uid }) => `
    #${uid} iframe.${uid}_prerender-frame {
        display: inline-block;
        position: absolute;

        /* loader frame size hardcoded intentionally*/
        width: 150px;
        height: 300px;

        /* center iframe inside parent relative */
        top: 50%;
        left: 50%;
        transform: translateX(-50%) translateY(-50%);
    }

    #${uid} iframe {
        opacity: 0;
        transition: opacity .2s ease-in-out;
    }

    #${uid} iframe.${uid}_invisible {
        opacity: 0;
        z-index: -1;
    }

    #${uid} iframe.${uid}_visible {
        opacity: 1;
    }
`;
var getLoaderCSS = () => `
    body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: fixed;
        top: 0;
        left: 0;
        margin: 0;
    }

    /* Active Animation */
    @-webkit-keyframes loader {
      from {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
      }
      to {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg);
      }
    }

    @keyframes loader {
      from {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
      }
      to {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg);
      }
    }


    .ui.loader.active,
    .ui.loader.visible {
      display: block;
    }
    .ui.loader {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      margin: 0;
      text-align: center;
      z-index: 1000;
      transform: translateX(-50%) translateY(-50%);
    }

    .ui.loader:before {
      position: absolute;
      content: '';
      top: 0;
      left: 50%;
      width: 100%;
      height: 100%;
      border-radius: 500rem;
      border: .2em solid rgba(0,0,0,.1);
    }

    .ui.loader:before {
      border: 0;
    }

    .ui.loader:after {
      position: absolute;
      content: '';
      top: 0;
      left: 50%;
      width: 100%;
      height: 100%;
      animation: loader .6s linear;
      animation-iteration-count: infinite;
      border-radius: 500rem;
      border-color: #e25468 transparent transparent;
      border-style: solid;
      border-width: .2em;
      box-shadow: 0 0 0 1px transparent;
    }


    .ui.inverted.dimmer .ui.loader,
    .ui.loader {
      width: 2.28571429rem;
      height: 2.28571429rem;
      font-size: 1em;
    }

    .ui.inverted.dimmer .ui.big.loader,
    .ui.big.loader {
      width: 3.71428571rem;
      height: 3.71428571rem;
      font-size: 1.28571429em;
    }

    .ui.loader:after,
    .ui.loader:before {
      width: 2.28571429rem;
      height: 2.28571429rem;
      margin: 0 0 0 -1.14285714rem;
    }

    .ui.big.loader:after,
    .ui.big.loader:before {
      width: 3.71428571rem;
      height: 3.71428571rem;
      margin: 0 0 0 -1.85714286rem;
    }
`;

// node_modules/pluggy-connect-sdk/dist/module/components/loader/html/index.js
var loaderComponentHtml = ({ nonce, text }) => `
        <div class='preloader spinner'>
            <style ${nonce ? `nonce="${nonce}"` : ""}>
              ${getLoaderCSS()}
            </style>

            <div class='ui big active loader'>
              ${text ? `<div class='content'>
                      <div class='ui text loader'>
                        ${text}
                      </div>
                    </div>` : ""}
            </div>
        </div>
`;

// node_modules/pluggy-connect-sdk/dist/module/components/modal/css/index.js
var getCSS = ({ uid, themeColor, height, width, allowFullscreen }) => `
/* Modal Content/Box */
@keyframes ${uid}_fadeIn {
  0% {
    opacity: 0;
  }
  50% {
    visibility: hidden;
    opacity: 0;
  }
  100% {
    visibility: visible;
    opacity: 1;
  }
}

#${uid} {
  /* prevent container el from taking site space */
  height: 0;

  /* prevent special container cursors from leaking in*/
  cursor: default;
}

.${uid}_has-modal-visible {
  /* modal is opened/visible, prevent scrolling */
  overflow: hidden;
}

.${uid}_close:hover,
.${uid}_close:focus {
  color: white;
  background: #${themeColor};
  text-decoration: none;
  cursor: pointer;
}

.${uid}_modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 5000000000;
  background: rgba(0, 0, 0, 0.7);
}

.${uid}_modal-container {
  /* center the modal content */
  display: flex;
  justify-content: center;
  align-items: center;
}

.${uid}_modal {
  width: ${width};
  max-width: 500px;
  height: ${height};
  max-height: 100%;
  z-index: 100;
  background: white;
  border: none;
  border-radius: 10px;

  /* modal box-shadow */
  -webkit-box-shadow: 0 4px 24px rgba(0,0,0,0.5);
  -moz-box-shadow: 0 4px 24px rgba(0,0,0,0.5);
  box-shadow: 0 4px 24px rgba(0,0,0,0.5);
  -webkit-background-clip: padding-box;
  -moz-background-clip: padding-box;
  background-clip: padding-box;
}

/* dark theme */
.${uid}_modal.dark {
  background: #121212;
}

.${uid}_closed {
  display: none;
}

.${uid}_modal-content {
  width: 100%;
  height: 100%;
  overflow: hidden;

  border-radius: 10px;
}

.${uid}_modal .close-button {
  position: absolute;
  z-index: 1;
  top: 10px;
  right: 20px;
  background: black;
  color: white;
  padding: 5px 10px;
  font-size: 1.3rem;
}

.${uid}_container {
    height: 100%;
    width: 100%;
    position: relative;
}

.${uid}_container iframe {
    height: 100%;
    width: 100%;
}

${allowFullscreen ? `
    /** when display is narrower that 500px (mobile device)
    open modal in full screen */
    @media screen and (max-width: 500px) {
      .${uid}_modal {
        height: 100%;
        width: 100%;
        border-radius: 0px;
        -webkit-box-shadow: none;
        -moz-box-shadow: none;
        box-shadow: none;
      }
    }` : ""}
`;

// node_modules/pluggy-connect-sdk/dist/module/components/modal/html/index.js
var getModalWrapper = (uid, theme) => `
<div class="${uid}_modal-overlay ${uid}_modal-container" id="${uid}_modal-overlay"/>
<div class="${uid}_modal ${theme}" id="${uid}_modal">
    <div class="${uid}_modal-content">
        <div class="${uid}_container"/>
    </div>
</div>
`;

// node_modules/pluggy-connect-sdk/dist/module/utils/cordova.js
function isRunningInCordova() {
  return typeof cordova !== "undefined";
}
function openInCordovaInAppBrowser(url, target) {
  if (!isRunningInCordova()) {
    throw new Error("Not running in Cordova");
  }
  if (!cordova.InAppBrowser) {
    console.error("Tried to open a link in cordova.InAppBrowser, but it's undefined! For the best experience, it's recommended to include plugin 'cordova-plugin-inappbrowser' in your build. Falling back to window.open() instead. Url:", url);
    window.open(url, target);
    return null;
  }
  const inAppBrowserWindow = cordova.InAppBrowser.open(url, target);
  return target === "_blank" ? inAppBrowserWindow : null;
}

// node_modules/pluggy-connect-sdk/dist/module/utils/oauth.js
function openOauthUrlInCordovaBrowser(url, onComplete) {
  const inAppBrowserWindow = openInCordovaInAppBrowser(url, "_blank");
  inAppBrowserWindow === null || inAppBrowserWindow === void 0 ? void 0 : inAppBrowserWindow.addEventListener("loadstop", (event) => {
    const { url: url2 } = event;
    const isPluggyOauthCallbackUrl = (url2.startsWith("https://api.pluggy.ai/") || url2.startsWith("https://api.pluggy.dev/") || url2.startsWith("http://localhost:9090/")) && url2.includes("/oauthCallback.html");
    if (!isPluggyOauthCallbackUrl) {
      return;
    }
    const params = new URLSearchParams(url2.split("?")[1]);
    const oauthResult = Object.fromEntries(params.entries());
    onComplete(oauthResult);
    inAppBrowserWindow.close();
  });
}

// node_modules/pluggy-connect-sdk/dist/module/utils/once.js
function once(fn) {
  let done = false;
  return function(...args) {
    if (done) {
      return void 0;
    }
    done = true;
    return fn.apply(this, args);
  };
}

// node_modules/pluggy-connect-sdk/dist/module/utils/props.js
function adaptPluggyConnectProps(props) {
  const { onError, onSuccess, onOpen, onClose, onEvent, onHide } = props;
  const adaptedPropsBase = Object.assign({}, props);
  delete adaptedPropsBase.onError;
  delete adaptedPropsBase.onSuccess;
  delete adaptedPropsBase.onOpen;
  delete adaptedPropsBase.onClose;
  delete adaptedPropsBase.onEvent;
  delete adaptedPropsBase.onHide;
  return Object.assign(Object.assign({}, adaptedPropsBase), { onErrorProp: onError, onSuccessProp: onSuccess, onOpenProp: onOpen, onCloseProp: onClose, onEventProp: onEvent, onHideProp: onHide });
}

// node_modules/pluggy-connect-sdk/dist/module/version.js
window.__PLUGGY_CONNECT_SDK_VERSION = "2.9.1";
var REACT_PLUGGY_CONNECT_PACKAGE_NAME = "react-pluggy-connect";
var PLUGGY_CONNECT_PACKAGE_NAME = "pluggy-connect-sdk";
function getSdkVersion() {
  const { __PLUGGY_CONNECT_SDK_VERSION, __REACT_PLUGGY_CONNECT_SDK_VERSION } = window;
  const sdkVersion = [];
  if (__REACT_PLUGGY_CONNECT_SDK_VERSION) {
    const reactPluggyConnectSdkversion = `${REACT_PLUGGY_CONNECT_PACKAGE_NAME}@${__REACT_PLUGGY_CONNECT_SDK_VERSION}`;
    sdkVersion.push(reactPluggyConnectSdkversion);
  }
  const pluggyConnectSdkVersion = `${PLUGGY_CONNECT_PACKAGE_NAME}@${__PLUGGY_CONNECT_SDK_VERSION}`;
  sdkVersion.push(pluggyConnectSdkVersion);
  return sdkVersion;
}

// node_modules/pluggy-connect-sdk/dist/module/pluggy-connect.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CONNECT_PRODUCTION_URL = "https://connect.pluggy.ai";
var zoidComponentInstance;
var pluggyConnectContainerUid;
function containerCssClassName(className) {
  return `${pluggyConnectContainerUid}_${className}`;
}
function initialize() {
  if (!zoidComponentInstance) {
    zoidComponentInstance = (0, import_zoid_frameworks.create)({
      // The html tag used to render the component
      tag: "pluggy-connect-widget",
      // The url of the page that will show in the iframe or popup, when someone includes the component on their site
      url: ({ props }) => {
        const { url: urlByProp = CONNECT_PRODUCTION_URL } = props;
        return urlByProp;
      },
      dimensions: {
        width: "320px",
        height: "568px"
      },
      props: {
        connectToken: {
          type: "string"
        },
        url: {
          type: "string",
          required: false
        },
        includeSandbox: {
          type: "boolean",
          required: false
        },
        allowConnectInBackground: {
          type: "boolean",
          required: false
        },
        allowFullscreen: {
          type: "boolean",
          required: false
        },
        updateItem: {
          type: "string",
          required: false
        },
        connectorTypes: {
          type: "array",
          required: false
        },
        connectorIds: {
          type: "array",
          required: false
        },
        countries: {
          type: "array",
          required: false
        },
        selectedConnectorId: {
          type: "number",
          required: false
        },
        language: {
          type: "string",
          required: false
        },
        theme: {
          type: "string",
          required: false
        },
        moveSecurityData: {
          type: "string",
          required: false
        },
        products: {
          type: "array",
          required: false
        },
        // object with CPF and CNPJ
        openFinanceParameters: {
          type: "object",
          required: false
        },
        sdkVersion: {
          type: "array",
          required: false,
          default: () => getSdkVersion()
        },
        _runningInCordova: {
          type: "boolean",
          required: false,
          default: () => isRunningInCordova()
        },
        onSuccessProp: {
          type: "function",
          required: false
        },
        onErrorProp: {
          type: "function",
          required: false
        },
        onOpenProp: {
          type: "function",
          required: false
        },
        onHideProp: {
          type: "function",
          required: false
        },
        onCloseProp: {
          type: "function",
          required: false
        },
        onEventProp: {
          type: "function",
          required: false
        }
      },
      attributes: {
        iframe: {
          scrolling: "no",
          title: "Pluggy"
        },
        popup: {
          scrolling: "no",
          title: "Pluggy"
        }
      },
      prerenderTemplate({ doc, props }) {
        const htmlNew = doc.createElement("html");
        htmlNew.innerHTML = loaderComponentHtml({
          nonce: props.cspNonce
        });
        return htmlNew;
      },
      containerTemplate({ doc, dimensions: { height, width }, close, uid, frame, prerenderFrame, event, props }) {
        if (!prerenderFrame || !frame) {
          throw new Error("Unexpected state: prerenderFrame or frame not defined");
        }
        pluggyConnectContainerUid = uid;
        const container = doc.createElement("div");
        const connectTheme = props.theme || "light";
        container.id = uid;
        container.innerHTML = getModalWrapper(uid, connectTheme);
        const frameContainer = container.querySelector(`.${uid}_container`);
        if (!frameContainer) {
          throw new Error("Unexpected state: not found frame container");
        }
        const visibleClassName = containerCssClassName("visible");
        const invisibleClassName = containerCssClassName("invisible");
        const prerenderFrameClassName = containerCssClassName("prerender-frame");
        frameContainer.appendChild(frame);
        frameContainer.appendChild(prerenderFrame);
        const style = doc.createElement("style");
        const allowFullscreenOrDefault = props.allowFullscreen !== void 0 ? props.allowFullscreen : true;
        style.innerHTML = [
          getCSS({
            uid,
            themeColor: "fafafa",
            height,
            width,
            allowFullscreen: allowFullscreenOrDefault
          }),
          getContainerCss({ uid })
        ].join("\n");
        container.appendChild(style);
        prerenderFrame.classList.add(prerenderFrameClassName);
        prerenderFrame.classList.add(visibleClassName);
        frame.classList.add(invisibleClassName);
        event.on(import_zoid_frameworks.EVENT.RENDERED, () => {
          prerenderFrame.classList.remove(visibleClassName);
          prerenderFrame.classList.add(invisibleClassName);
          frame.classList.remove(invisibleClassName);
          frame.classList.add(visibleClassName);
        });
        const modalVisibleClassName = containerCssClassName("has-modal-visible");
        event.on(import_zoid_frameworks.EVENT.DISPLAY, () => {
          document.body.classList.add(modalVisibleClassName);
          const { onOpenProp } = props;
          onOpenProp === null || onOpenProp === void 0 ? void 0 : onOpenProp();
        });
        const onClosePropWrapper = props.onCloseProp ? once(props.onCloseProp) : null;
        event.on(import_zoid_frameworks.EVENT.CLOSE, () => {
          document.body.classList.remove(modalVisibleClassName);
          onClosePropWrapper === null || onClosePropWrapper === void 0 ? void 0 : onClosePropWrapper();
        });
        window.addEventListener("message", (event2) => {
          const { origin, data } = event2;
          const { url: connectWebappUrl = "https://connect.pluggy.ai" } = props;
          if (origin !== connectWebappUrl) {
            return;
          }
          let pluggyConnectMessage;
          try {
            pluggyConnectMessage = JSON.parse(data);
          } catch (_a) {
            return;
          }
          if (pluggyConnectMessage.type === "OAUTH_OPEN" && isRunningInCordova()) {
            const { message: oauthUrl } = pluggyConnectMessage;
            openOauthUrlInCordovaBrowser(oauthUrl, (payload) => {
              var _a;
              return (_a = frame.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(payload, "*");
            });
            return;
          }
          if (pluggyConnectMessage.type === "LINK_OPEN" && isRunningInCordova()) {
            const { message: externalUrl } = pluggyConnectMessage;
            openInCordovaInAppBrowser(externalUrl, "_system");
            return;
          }
          if (pluggyConnectMessage.type === "CONTINUE_IN_BACKGROUND") {
            document.body.classList.remove(modalVisibleClassName);
            return;
          }
        }, false);
        document.addEventListener("keydown", function escapeKeyCloseHandler(event2) {
          if (event2.key !== "Escape") {
            return;
          }
          close();
          document.removeEventListener("keydown", escapeKeyCloseHandler);
        });
        return container;
      }
    });
  }
  return zoidComponentInstance;
}
var PluggyConnect = class {
  constructor(props) {
    this.zoidComponent = initialize();
    const extendedProps = Object.assign(Object.assign({}, props), { sdkVersion: getSdkVersion() });
    this.componentPropsExtendedAdapted = adaptPluggyConnectProps(extendedProps);
  }
  /**
   * Render the component using the specified component props,
   * as a modal with an iframe, appended to the page body (or the DOM uppermost element).
   *
   * @param containerElement - parent element where component should be rendered at. If not specified, will render at body root element.
   * @returns promise that resolves when rendered successfully, or throws if failed.
   */
  init(containerElement) {
    const container = containerElement || (document.getElementsByTagName("body") || document.getElementsByTagName("html") || document.getElementsByTagName("div"))[0];
    this.componentInstance = this.zoidComponent(this.componentPropsExtendedAdapted);
    return this.componentInstance.render(container).catch((error) => {
      console.error(`Failed to render <PluggyConnect /> component`, error);
      throw error;
    });
  }
  /**
   * Manually cleanup the component.
   * This is not recommended, you should create the component once
   * and re-render it as needed each new time to save resources.
   */
  destroy() {
    zoidComponentInstance = void 0;
    return (0, import_zoid_frameworks.destroy)();
  }
  /**
   * If the component is minimized, re-open it.
   * @retruns promise that resolves when re-opened successfully, or throws if failed.
   */
  show() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.componentInstance) {
        throw new Error("Failed to show <PluggyConnect /> component: component not initialized");
      }
      try {
        yield this.componentInstance.show();
        const modalVisibleClassName = containerCssClassName("has-modal-visible");
        document.body.classList.add(modalVisibleClassName);
      } catch (error) {
        console.error(`Failed to show <PluggyConnect /> component`, error);
        throw error;
      }
    });
  }
  /**
   * Minimize the component.
   * Useful if you want to hide Connect widget after credentials have been submitted,
   * and you want to just continue connecting in background while still listening to
   * other callback events.
   */
  hide() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.componentInstance) {
        throw new Error("Failed to hide <PluggyConnect /> component: component not initialized");
      }
      try {
        yield this.componentInstance.hide();
        const modalVisibleClassName = containerCssClassName("has-modal-visible");
        document.body.classList.remove(modalVisibleClassName);
      } catch (error) {
        console.error(`Failed to hide <PluggyConnect /> component`, error);
        throw error;
      }
    });
  }
};

// node_modules/react-pluggy-connect/dist/module/react-pluggy-connect.js
var import_react = __toESM(require_react());

// node_modules/react-pluggy-connect/dist/module/version.js
window.__REACT_PLUGGY_CONNECT_SDK_VERSION = "2.9.0";

// node_modules/react-pluggy-connect/dist/module/react-pluggy-connect.js
var PluggyConnect2 = (props) => {
  const propsRef = (0, import_react.useRef)(props);
  const pluggyConnectContainerRef = (0, import_react.useCallback)((containerElement) => {
    const { current: currentProps } = propsRef;
    const { innerRef, onLoadError } = currentProps;
    if (containerElement === null) {
      innerRef === null || innerRef === void 0 ? void 0 : innerRef(null);
      return;
    }
    const pluggyConnect = new PluggyConnect(currentProps);
    pluggyConnect.init(containerElement).then(() => {
      try {
        innerRef === null || innerRef === void 0 ? void 0 : innerRef({
          show: pluggyConnect.show.bind(pluggyConnect),
          hide: pluggyConnect.hide.bind(pluggyConnect)
        });
      } catch (error) {
        console.error("Unexpected error caught in <PluggyConnect/> when calling innerRef prop:", error);
      }
    }).catch((error) => {
      onLoadError === null || onLoadError === void 0 ? void 0 : onLoadError(error);
    });
  }, []);
  return import_react.default.createElement("div", { id: "PluggyConnect", ref: pluggyConnectContainerRef });
};
export {
  PluggyConnect2 as PluggyConnect
};
//# sourceMappingURL=react-pluggy-connect.js.map
